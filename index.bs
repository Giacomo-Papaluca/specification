<pre class="metadata">
Title: Shape Trees Specification
Shortname: shapetrees-spec
Level: 1
Max ToC Depth: 2
Status: w3c/ED
Group: w3c
URL: https://shapetrees.org/TR/specification/
Editor: Eric Prud'hommeaux
Editor: Justin Bingham
Markup Shorthands: markdown yes
Abstract:
    Semantic Web Applications interoperate by sharing semantics of terms and
    constellations of resource-oriented data structures. This specification
    defines shape trees, a mechanism for declaring and operating over
    constellations of resource-oriented data structures.
</pre>

<!-- For bikeshed style overrides -->
<style>

  em.rfc2119 {
    text-transform: lowercase;
    font-variant: small-caps;
    font-style: normal;
    font-size: 18px;
    color: #900;
  }

  figcaption {
    text-align: left;
  }

  pre {
    font-size: 12px;
  }

  a[href*=".ttl"] {
    color: #339966;
    border-bottom: 1px solid #339966;
  }

  a[href*=".shex"] {
    color: #cc2900;
    border-bottom: 1px solid #cc2900;
  }

  a[href*=".tree"] {
    color: #e68a00;
    border-bottom: 1px solid #e68a00;
  }

  a[data-link-type=dfn] {
    color: #000000;
  }

  table.tree thead tr {
    font-size: 14px;
  }
  
  table.tree tbody tr:nth-child(even) {
    background-color: lightgray;
    font-size: 14px;
  }
  
  table.tree tbody td {
    font-size: 12px;
  }

  table.operation {
    border-collapse: separate;
    border: 3px solid #808080;
    margin-bottom: .5em;
  }

  table.operation thead tr {
    font-size: 14px;
  }

  table.operation thead th {
    background-color: #005A9C;
    color: #FFF;
  }

  table.operation th[colspan] {
    text-align: left;
  }

  table.operation td[colspan] {
    text-align: left;
  }

  table.operation tbody td {
    font-size: 13px;
    text-align: left;
  }

  table.operation code {
    background-color: #DCDCDC;
    color: #000;
    font-size: 13px;
    padding-left: .2em;
    padding-right: .2em;
    padding-top: .05em;
    padding-bottom: .05em;  
  }

  .opdetails code {
    background-color: #DCDCDC; 
    color: #000;
    font-weight: bold;
    font-size: 13px;
    padding-left: .2em;
    padding-right: .2em;
    padding-top: .05em;
    padding-bottom: .05em;
  }

  .opdetails code.vocab {
    color: #339966;
    background-color: #FFFFFF;
  }

  .opdetails ol {
    margin-left: 0;
    padding-left: 1em;
  }

	code.container {
		color: #005555;
	}

	code.notes {
		color: #770033;
	}

	code.citation {
		color: #330077;
	}

	code.image {
		color: #337700;
	}

    code.vocab {
		color: #339966;
	}
</style>

<div boilerplate="copyright">
  <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2020
  <a href="https://www.w3.org/">W3C</a>®
  (<a href="https://www.csail.mit.edu/">MIT</a>,
   <a href="https://www.ercim.eu/">ERCIM</a>,
   <a href="https://www.keio.ac.jp/">Keio</a>,
   <a href="https://ev.buaa.edu.cn/">Beihang</a>).
   W3C
   <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
   <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
   <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">permissive document license</a>
   rules apply.
</div>

Introduction {#introduction}
=====================

*This section is non-normative.*

Realizing the value proposition of the Semantic Web lies in building useful and
robust applications that can interoperate over linked data. Protocols such as
[[LDP]] and [[Solid]] organize linked data graphs into resource hierarchies,
providing a foundation upon which these robust and interoperable applications
can be created.

Application interoperability depends on applications sharing semantics for
relationships and data structures.  Existing technologies fulfill portions
of those dependencies:
* [[RDF]]&apos;s foundation in unambiguous identifiers provides an infrastructure
    that allows for interoperability, but does not specifically encourage or enforce it.
* [=Shape=] languages (e.g. [[ShEx]] and [[SHACL]]) provide machine-readable,
    enforceable data structure definitions on single resources.

For applications that operate on more complex and interconnected resources,
<i>[=Shape Trees=]</i> express the layout of those resources and associate them
with their respective [=shapes=].

[=Shape trees=] marry [[RDF]] vocabularies, shapes, and resources into
"little trees" that provide machine to machine interoperability, combining them
into concepts that humans can easily comprehend, such as medical records, notes,
notebooks, calendars, and financial records.

This allows one to treat a set of related resources as a single grouping, and
apply that to a range of operations including access control, data organization,
data validation, and data migration.

While [=shape trees=] are intended to adapt to different technology platforms
that support the notion of [=containers=] and [=resources=], examples in this
specification will reflect usage in an [[LDP]] environment.

[=Shape trees=] are defined as an [=RDF=] graph structure that expresses a set
of expected behaviors by agents that work with them. This provides a sort of
type-safety of resource hierarchies called <dfn>shape tree consistency</dfn>.
These semantics CAN be implemented by a [=server-side agent=], or by a
[=client-side agent=] that implements [=shape tree=] operations as primitive
requests to a server.

[=Shape tree=] support by a [=server-side agent=] ensures [=shape tree
consistency=] by managing all manipulations of data within a resource hierarchy
(see [=managed resource=]).

## ShapeTree Support From Proxy or Client-side Library

If a server does not support [=shape trees=], some [=shape tree consistency=]
can be achieved by implementing [=shape tree=] support in the client, typically
in a library than can enforce consistency for any clients using the
library. Primitive operations by other clients not using the library may leave the
resource hierarchy in an inconsistent state.

For client-side shape tree libraries that operate by intercepting HTTP
operations, this specification serves as an API for those client
interactions. (Additionally, if [=shape tree=] support is later added to the
server, the client's execution of [=shape tree=] operations does not change.) In
the remainder of this document, [=shape tree=] operations are described in terms
of a [=client-side agent=] performing operations on a [=server-side agent=] with
support for [=shape trees=].

A proxy performing [=shape tree=] operations would be indistinguishable from
server support except that clients performing primitive operations directly on
the server (bypassing the proxy) may leave the server in an inconsistent state.

Shape Tree {#tree}
=====================

A <dfn>shape tree</dfn> is a machine-readable template describing the 
expected layout of a tree of resources in a [=container=]-based [=ecosystem=].
A [=shape tree=] expresses a tree hierarchy by containing
other [=shape trees=]. The terms used to express a [=shape tree=] are described 
using an [[RDF]] [vocabulary](shapetree.ttl).

A <dfn>shape tree instance</dfn> is a resource or set of resources assigned to 
and in conformance with a given [=shape tree=]. A resource in a
[=shape tree instance=] is called a <dfn>managed resource</dfn>.

Every [=managed resource=] has an associated [=shape tree locator=].
A [=shape tree locator=] identifies the [=shape tree=] associated
with a [=managed resource=], and additional information needed to navigate 
nested hierarchies of managed resources. A resource becomes a 
[=managed resource=] when a [=shape tree locator=] is associated with it 
through the [[#plant-shapetree]] operation.

The <code class="vocab">st:expectsType</code> property of a [=shape tree=] 
specifies that the described [=managed resource=] be one of these three types:

<table class="data" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <tbody>
    <tr>
      <td><code class="vocab">st:Resource</code></td>
      <td>Regular RDF resource that is not a container</td>
    </tr>
    <tr>
      <td><code class="vocab">st:Container</code></td>
      <td>RDF resource that uses server-managed metadata to
      enumerate nested resources</td>
    </tr>
    <tr>
      <td><code class="vocab">st:NonRDFResource</code></td>
      <td>Non-RDF resource such as binaries or images</td>
    </tr>
  </tbody>
</table>

The <code class="vocab">st:shape</code> property specifies that the 
described [=managed resource=] conforms to the stated [[ShEx]] or [[SHACL]] 
shape.

[=Shape trees=] prescribe physical hierarchies and can reference other
shape trees to form virtual hierarchies. 

For physical hierarchies, the <code class="vocab">st:contains</code>
property asserts that a [=managed resource=] is a [=container=] that
explicitly contains another [=managed resource=].

If [=shape tree=] `S1` <code class="vocab">st:contains</code> [=shape tree=] 
`S2`, `S1` describes a [=container=] that contains another [=managed resource=] 
described by `S2`. For example, in [[LDP]], `S1` describes 
an [[LDP]] [=container=] which <code class="vocab">ldp:contains</code> nested 
resources described by `S2`. [=Shape tree=] `S2` and the nested resources 
associated with it are considered to be <dfn>in-scope</dfn> of the containing 
[=shape tree=] `S1`.

<figure id="shapetree-physical">
  <figcaption>Shape tree validation of a physical hierarchy</figcaption>
  <table class="data tree" align="left">
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Associated Shape Tree</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/project-1/`</td>
        <td>`ex:ProjectTree`</td>
      </tr>
      <tr>
        <td>`-- /milestone-A/`</td>
        <td>`ex:MilestoneTree`</td>
      </tr>
      <tr>
        <td>`---- /task-43/`</td>
        <td>`ex:TaskTree`</td>
      </tr>
      <tr>
        <td>`---- /task-48/`</td>
        <td>`ex:TaskTree`</td>
      </tr>
      <tr>
        <td>`------ /attachment-aa89`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`---- /task-61/`</td>
        <td>`ex:TaskTree`</td>
      </tr>
      <tr>
        <td>`---- /issue-22/`</td>
        <td>`ex:IssueTree`</td>
      </tr>
      <tr>
        <td>`------ /attachment-cd12`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`------ /attachment-ef55`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`---- /issue-31/`</td>
        <td>`ex:IssueTree`</td>
      </tr>
    </tbody>
  </table>
  
  <pre highlight="turtle">
    PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
    PREFIX ex: &lt;http://www.example.com/ns/ex#&gt;

    <#ProjectTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:ProjectShape ;
      st:contains <#MilestoneTree> .

    <#MilestoneTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:MilestoneShape ;
      st:contains <#TaskTree>, <#IssueTree> .

    <#TaskTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:TaskShape ;
      st:contains st:NonRDFResourceTree .

    <#IssueTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:IssueShape ;
      st:contains st:NonRDFResourceTree .

  </pre>

</figure>

A virtual hierarchy is defined by [=shape tree references=] that link to
other [=shape trees=] by the <code class="vocab">st:references</code>
property.
A <dfn>shape tree reference</dfn> 
identifies the [=shape tree=] to be referenced via 
<code class="vocab">st:hasShapeTree</code>, and the [=shape path=] through 
which it is linked via <code class="vocab">st:viaShapePath</code>. 

A <dfn>shape path</dfn> is a string that defines a traversal 
of a [=shape=] schema. [[SHEXPATH]]

<figure id="shapetree-virtual">
  <figcaption>Shape tree validation of a virtual hierarchy</figcaption>
  <table class="data tree" align="left">
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Associated Shape Tree</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/project-1`</td>
        <td>`ex:VirtualProjectTree`</td>
      </tr>
      <tr>
        <td>`/milestone-A`</td>
        <td>`ex:VirtualMilestoneTree`</td>
      </tr>
      <tr>
        <td>`/task-43`</td>
        <td>`ex:VirtualTaskTree`</td>
      </tr>
      <tr>
        <td>`/task-48`</td>
        <td>`ex:VirtualTaskTree`</td>
      </tr>
      <tr>
        <td>`/attachment-aa89`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`/task-61`</td>
        <td>`ex:VirtualTaskTree`</td>
      </tr>
      <tr>
        <td>`/issue-22`</td>
        <td>`ex:VirtualIssueTree`</td>
      </tr>
      <tr>
        <td>`/attachment-cd12`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`/attachment-ef55`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`/issue-31`</td>
        <td>`ex:VirtualIssueTree`</td>
      </tr>
    </tbody>
  </table>

  <pre highlight="turtle">
    PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
    PREFIX ex: &lt;http://www.example.com/ns/ex#&gt;

    <#VirtualProjectTree>
      a st:ShapeTree ;
      st:expectsType st:Resource ;
      st:shape ex:ProjectShape ;
      st:references [
        st:hasShapeTree <#VirtualMilestoneTree> ;
        st:viaShapePath "@ex:ProjectShape~ex:hasMilestone"
      ] .

    <#VirtualMilestoneTree>
      a st:ShapeTree ;
      st:expectsType st:Resource ;
      st:shape ex:MilestoneShape ;
      st:references [
        st:hasShapeTree <#VirtualTaskTree> ;
        st:viaShapePath "@ex:MilestoneShape~ex:hasTask"
      ] ,
      [
        st:hasShapeTree <#VirtualIssueTree> ;
        st:viaShapePath "@ex:MilestoneShape~ex:hasIssue"
      ] .

    <#VirtualTaskTree>
      a st:ShapeTree ;
      st:expectsType st:Resource ;
      st:shape ex:TaskShape ;
      st:references [
        st:hasShapeTree st:NonRDFResourceTree ;
        st:viaShapePath "@ex:TaskShape~ex:hasAttachment"
      ] .

    <#VirtualIssueTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:IssueShape ;
      st:references [
        st:hasShapeTree st:NonRDFResourceTree ;
        st:viaShapePath "@ex:IssueShape~ex:hasAttachment"
      ] .
  </pre>

</figure>

Let <code>ST</code> be a [=shape tree=]. 
Let <code>STI</code> be a corresponding [=shape tree instance=].

* An { `ST` <code class="vocab">st:expectsType</code> `T` } [=triple=] identifies
    the resource type `T` of a  corresponding [=managed resource=] 
    <code>R</code> in <code>STI</code> 
    where `T` <em class="rfc2119">MUST</em> be one of
    <code class="vocab">st:Resource</code>,
    <code class="vocab">st:Container</code>, or
    <code class="vocab">st:NonRDFResource</code>.
* An { `ST` <code class="vocab">rdfs:label</code> `L` } [=triple=]
    indicates that there is at most one corresponding [=managed resource=] 
    `R` in `STI` and it has the name `L`. `L` is a <dfn>static resource</dfn>.
* An { `ST` <code class="vocab">st:shape</code> `SH` }
    [=triple=] indicates that [=managed resource=] `R` has
    at most one node which conforms to [=shape=] `SH`.
* An { `ST` <code class="vocab">st:contains</code> `ST2` }
    [=triple=] identifies a nested [=shape tree=] `ST2`.
* An { `ST` <code class="vocab">st:references</code> `STR` }
    [=triple=] indicates that the [=shape tree=] identified in
    [=shape tree reference=] `STR`, is referenced through the
    instance data of `STI`.
    * An { `STR` <code class="vocab">st:hasShapeTree</code> `ST3` } [=triple=]
        indicates a [=shape tree=] referenced through the instance data of `STI`
    * An { `STR` <code class="vocab">st:viaShapePath</code> `SHPH` } 
        [=triple=] identifies the [=shape path=] through which a
        [=shape tree instance=] of `ST3` can be found via the instance data of
        `STI`
* An { `ST` <code class="vocab">st:supports</code> `ST4` }
    [=triple=] indicates that `ST` provides supporting or supplementary
    context to `ST4`.

A { `ST` <code class="vocab">st:hasShapeTreeDecoratorIndex</code> `DI` }
    [=triple=] indicates the location of an index of [SKOS hierarchies](#skos-graph)
    that describes `ST`.

## Shape Tree Schema ## {#st-schema}

<figure id="shapetree-shex">
  <figcaption>ShEx Schema for a Shape Tree</figcaption>
	<pre highlight="turtle">
    PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
    PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
    PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
    
    <#ShapeTree> {
      a st:ShapeTree ;
      (
        st:expectsType [st:Container] ;
        st:contains @<#ShapeTree> * ; 
        |
        st:expectsType [st:Resource st:NonRDFResource]
      ) ;
      rdfs:label xsd:string ? ;
      st:references @<#ReferencedShapeTree> * ;
      st:shape IRI ? ;
      st:contains IRI ? ;
      st:supports IRI ? 
    }
    
    <#ReferencedShapeTree> {
      st:hasShapeTree IRI ;
      st:viaShapePath xsd:string
    }

	</pre>
</figure>

Shape Tree Locator {#locator}
=====================

A <dfn>shape tree locator</dfn> associates a [=managed resource=] with 
one or more [=shape trees=]. No more than one [=shape tree locator=] may be
associated with a [=managed resource=]. 

For example, in [[Solid]] a [=shape tree locator=] would be stored in an
[auxiliary resource](https://solidproject.org/TR/protocol#auxiliary-resources) 
associated with a given [=managed resource=].

A [=shape tree locator=] includes one or more [=shape tree locations=] via
<code class="vocab">st:location</code>. Each <dfn>shape tree location</dfn> 
identifies a [=shape tree=] 
and the [=managed resource=] it is associated with, the focus node for [=shape=] 
validation, and the information 
needed to navigate the physical hierarchy in which that [=managed resource=]
resides.

If there is more than one [=shape tree location=], they all apply to the same
[=managed resource=] associated with the [=shape tree locator=].

[=Shape tree locations=] identify key contextual points in a physical hierarchy:

* A <dfn>root shape tree location</dfn> marks the [=shape tree location=] 
    associated with the root [=managed resource=] in a physical hierarchy, and 
    is set by the [Plant Operation](#plant-shapetree).

<figure id="shapetree-location-properties">
  <figcaption>Shape Tree Location properties</figcaption>
  <table class="data" align="left">
    <colgroup></colgroup>
    <colgroup></colgroup>
    <thead>
      <tr>
        <th>Property</th>
        <th>Description</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code class="vocab">st:hasShapeTree</code></td>
        <td>Identifies the [=shape tree=] to be associated with 
        the [=managed resource=]</td>
      </tr>
      <tr>
        <td><code class="vocab">st:hasManagedResource</code></td>
        <td>Identifies the [=managed resource=] associated with the [=shape tree location=]</td>
      </tr>
      <tr>
        <td><code class="vocab">st:hasRootShapeTreeLocation</code></td>
        <td>Identifies the [=root shape tree location=]</td>
      </tr>
      <tr>
        <td><code class="vocab">st:node</code></td>
        <td>Identifies the focus node for [=shape=] validation 
        in the associated [=managed resource=], and is only valid when the 
        corresponding [=shape tree=] includes 
        <code class="vocab">st:shape</code></td>
      </tr>    
      <tr>
        <td><code class="vocab">st:shape</code></td>
        <td>Identifies the [=shape=] to which <code class="vocab">st:node</code> 
        must conform, and must be equivalent to <code class="vocab">st:shape</code>
        in the corresponding [=shape tree=]</td>
      </tr>
    </tbody>
  </table>
</figure>
  
A [=root shape tree=], and its corresponding [=managed resource=] can
be planted within an existing managed hierarchy, alongside or within other
[=root shape trees=] and [=managed resources=].

[=Shape tree locations=]
in a given [=shape tree locator=] may have different
focus nodes.

<figure id="shapetree-navigation">
  <figcaption>Navigating a physical shape tree hierarchy</figcaption>
  <table class="data tree" align="left">
    <colgroup>
    <colgroup>
    <col>
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Shape Tree</th>
        <th>Root Shape Tree</th>
        <th>Root Managed Resource</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/data/`</td>
        <td>`ex:DataTree`</td>
        <td>`ex:DataTree`</td>
        <td>`/data/`</td>
      </tr>
      <tr>
        <td>`-- /projects/`</td>
        <td>`ex:DataCollectionTree`<br/>
            `ex:ProjectCollectionTree`</td>
        <td>`ex:DataTree`<br/>
            `ex:ProjectCollectionTree`</td>
        <td>`/data/`<br/>
            `/data/projects/`</td>
      </tr>
      <tr>
        <td>`---- /project-1/`</td>
        <td>`ex:ProjectTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`------ /milestone-A/`</td>
        <td>`ex:MilestoneTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /task-43/`</td>
        <td>`ex:TaskTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /task-48/`</td>
        <td>`ex:TaskTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`---------- /attachment-aa89`</td>
        <td>`ex:AttachmentTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /task-61/`</td>
        <td>`ex:TaskTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /issue-22/`</td>
        <td>`ex:IssueTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`---------- /attachment-cd12`</td>
        <td>`ex:AttachmentTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`---------- /attachment-ef55`</td>
        <td>`ex:AttachmentTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /issue-31/`</td>
        <td>`ex:IssueTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
    </tbody>
  </table>
</figure>

<figure id="locator-multiple-locations">
  <figcaption>[=Shape Tree Locator=] for /data/projects/ with multiple 
    [=shape tree locations=] in a nested physical hierarchy</figcaption>
  <pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
  PREFIX ex: &lt;http://www.example/ns/ex#&gt;

  &lt;&gt; st:hasShapeTreeLocator &lt;#locator&gt; .

  &lt;#locator&gt;
    a st:ShapeTreeLocator ;
    st:location <#location1>, <#location2> .
    
  <#location1>
    st:hasShapeTree ex:DataCollectionTree ;
    st:hasManagedResource &lt;https://storage.example/data/projects/&gt;
    st:hasRootShapeTreeLocation &lt;https://storage.example/data/.shapetree#location1&gt; ;
    st:node &lt;https://storage.example/data/projects/#collection&gt; ;
    st:shape ex:DataCollectionShape .
  
  <#location2>
    st:hasShapeTree ex:ProjectCollectionTree ;
    st:hasManagedResource &lt;https://storage.example/data/projects/&gt;
    st:hasRootShapeTreeLocation &lt;https://storage.example/data/projects/.shapetree#location2&gt; ;
    st:node &lt;https://storage.example/data/projects/#collection&gt; ;
    st:shape ex:ProjectCollectionShape .
  </pre>

</figure>

<figure id="locator-single">
  <figcaption>[=Shape Tree Locator=] for 
    /data/projects/project-1/milestone-A/task-48 with a single 
    [=shape tree location=] in a nested physical hierarchy</figcaption>
  <pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
  PREFIX ex: &lt;http://www.example/ns/ex#&gt;

  &lt;&gt; st:hasShapeTreeLocator &lt;#locator&gt; .

  &lt;#locator&gt;
    a st:ShapeTreeLocator ;
    st:location <#location1> .

    <#location1>
      st:hasShapeTree ex:TaskTree ;
      st:hasManagedResource &lt;https://storage.example/data/projects/project-1/milestone-A/task-48&gt; ;
      st:hasRootShapeTreeLocation &lt;https://storage.example/data/projects/.shapetree#location2&gt; ;
      st:node &lt;https://storage.example/data/projects/project-1/milestone-A/task-48#task&gt; ;
      st:shape ex:ProjectCollectionShape .
  </pre>

</figure>

A [=shape tree location=] may be used to provide shape validation only,
in which case only the focus node and shape are provided, via 
<code class="vocab">st:node</code> and 
<code class="vocab">st:shape</code>, respectively. 

<figure id="shapetree-navigation-shapeonly">
  <figcaption>A [=shape tree locator=] providing only 
  shape validation</figcaption>
  <table class="data tree" align="left">
    <colgroup>
    <colgroup>
    <col>
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Shape</th>
        <th>Focus Node</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/data/projects/project-1`</td>
        <td>`ex:ProjectShape`</td>
        <td>`/data/projects/project-1#project`</td>
      </tr>
    </tbody>
  </table>
</figure>

<pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
  PREFIX ex: &lt;http://www.example/ns/ex#&gt;
  PREFIX project1: &lt;https://storage.example/data/projects/project-1#&gt;
  
  &lt;&gt; st:hasShapeTreeLocator &lt;#locator&gt; .

  &lt;#locator&gt;
    a st:ShapeTreeLocator ;
    st:location <#location1> .

    <#location1>
      st:node &lt;https://storage.example/data/projects/project-1#project&gt; ;
      st:shape ex:ProjectShape .

</pre>


## Shape Tree Locator Schema ## {#st-locator-schema}

<figure id="shapetree-locator-shex">
  <figcaption>ShEx Schema for a Shape Tree Locator</figcaption>
	<pre highlight="turtle">
    PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
    PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
    PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
    
    &lt;#ShapeTreeLocatorShape&gt; {
      a [st:ShapeTreeLocator] ;
      st:location @&lt;#ShapeTreeLocationShape&gt;+
    }	
    
    &lt;#ShapeTreeLocationShape&gt; {
      st:hasShapeTree IRI ;
      st:hasManagedResource IRI ;
      st:hasRootShapeTreeLocation IRI ;
      ( st:node IRI ;
        st:shape IRI )?
      |
      st:node IRI ;
      st:shape IRI
    }
</pre>
</figure>

Shape Tree Operations {#operations}
=====================

Working with [=shape trees=] entails using several higher-level operations --
each of which may represent one or more HTTP requests and/or pieces of
processing logic.

In regular use, a [=client-side agent=] manipulates resources on a 
[=resource server=] running a [=server-side agent=]. That [=server-side agent=] 
applies logic for [=shape tree=] validation and navigation where applicable
when processing requests from [=client-side agents=]. 

The key operations used to manage [=shape trees=] are:
* [Discover Shape Tree](#discover) - determine the [=shape tree=] linked to some [=managed resource=].
* [Plant Shape Tree](#plant-shapetree) - declare that a resource will henceforth be managed by the provided [=shape tree=].
* [Unplant Shape Tree](#unplant-shapetree) - assert that a managed resource should no longer be managed by the provided [=shape tree=].
* [Create Shape Tree Instance](#create-shape-tree-instance) - add a resource to a managed resource hierarchy.
* [Update Shape Tree Instance](#update-shape-tree-instance) - modify a resource in a managed resource hierarchy.
* [Delete Shape Tree Instance](#delete-shape-tree-instance) - remove a resource in a managed resource hierarchy.

These operations make use of reusable, internal algorithms defined in
[Shape Tree Algorithms](#algorithms).

[=Shape tree=] logic can be applied by [=server-side agents=]
implementing different protocols such as [[LDP]] or [[Solid]]. The operations
defined herein defer to the implementing protocol as to the appropriate
status code and composition of HTTP responses.

Note: Server-side processing of changes to [=shape tree locators=]
can support the addition and removal of multiple [=shape tree locations=]
at once. For simplicity, this specification provides discreet client-side
operations to plant or unplant one shape tree at a time. However, it
would not be inappropriate to provide client implementations that
support requests to plant and unplant multiple shape trees for a 
given [=resource=] in a single request.

## Discover Shape Tree ## {#discover}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation is used by a [=client-side agent=] to discover  
        any [=shape trees=] associated with a given [=resource=].
        
        If `URI` is a [=managed resource=], the associated 
        [=Shape Tree Locator=] will be returned.  
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESOURCEURI`</td>
      <td>The URI of the resource to discover shape trees for</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`LOCATOR`</td>
      <td>[=Shape tree locator=] associated with the [=managed resource=]</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP HEAD or GET on the provided <code>RESOURCEURI</code>.  

<pre highlight="http">
  HEAD https://storage.example/data/projects/
</pre>

<pre highlight="http">
  HTTP/1.1 200 OK
  Link: &lt;https://storage.example/meta/c560224b#locator&gt;; rel="http://www.w3.org/ns/shapetrees#ShapeTreeLocator"
  Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel="type"
  ...other HTTP response headers omitted...
</pre>

2. Let <code>LOCATORURI</code> be the URI of a [=shape tree locator=] 
    associated with `RESOURCEURI` with a Link relation type of 
    `http://www.w3.org/ns/shapetrees#ShapeTreeLocator`.
   
3. If `LOCATORURI` is missing, the resource at 
    `RESOURCEURI` is not a [=managed resource=], and no [=shape tree locator=] 
    will be returned.
   
4. Perform an HTTP GET on `LOCATORURI`

<pre highlight="http">
  GET https://storage.example/data/projects/.shapetree
</pre>

<pre highlight="turtle">
  ...HTTP response headers omitted...
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
  PREFIX ex: &lt;http://www.example/ns/ex#&gt;

  &lt;&gt; st:hasShapeTreeLocator &lt;#locator&gt; .

  &lt;#locator&gt;
    a st:ShapeTreeLocator ;
    st:location <#location1> .
    
  <#location1>
    st:hasShapeTree ex:DataCollectionTree ;
    st:hasManagedResource &lt;https://storage.example/data/projects/&gt;
    st:hasRootShapeTreeLocation &lt;https://storage.example/data/.shapetree#location1&gt; ;
    st:node &lt;https://storage.example/data/projects/#collection&gt; ;
    st:shape ex:DataCollectionShape .
</pre>

5. If a corresponding resource at `LOCATORURI` is not found, it 
    <em class="rfc2119">MUST</em> be considered
    an [=unmanaged resource=].

<pre highlight="http">
GET https://storage.example/data/projects/.shapetree
</pre>

<pre highlight="http">
HTTP/1.1 404 Not Found
</pre>

5. If `LOCATORURI` contains a valid [=shape tree locator=],
    the resource at `RESOURCEURI` <em class="rfc2119">MUST</em> be considered a 
    [=managed resource=].

</div>

## Plant Shape Tree ## {#plant-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation marks an existing [=resource=] as managed by 
        one or more shape trees, by creating or updating an associated 
        [=shape tree locator=]. 

        If the 
        [=resource=] is already managed, the associated [=shape tree locator=]
        will be updated with another [=shape tree location=] for the 
        planted [=shape tree=].

        If the [=resource=] is a container that already contains existing
        resources, this operation will perform a depth first traversal through 
        the containment hierarchy, validating and assigning as it works its 
        way back up to the target resource of this operation.

      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#plant-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the resource to plant on</td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>A URI representing the shape tree to plant for `TR`</td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>An <em class="rfc2119">OPTIONAL</em> URI representing the 
      subject within `TR` used as the focus node for shape validation</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. [Discover](#discover) if `TR` is a [=managed resource=]. 
    * Let `LOCATORURI` be the URI of the [=Shape Tree Locator=] associated 
        with `TR`.
1. Perform an HTTP `PUT` or `PATCH` on `LOCATORURI` to create or update the 
    [=Shape Tree Locator=] for `TR`
    * Add a new `st:ShapeTreeLocation LN`  
      * Let `LN hasShapeTree` be `TST`
      * Let `LN hasManagedResource` be `TR`      
      * Let `LN hasRootShapeTreeLocation` be `LN`
      * If `TST` has an `st:shape`
          * Let `LN st:shape` be the object value of `TST st:shape`
          * Let `LN st:node` be `FN`

</div>

<pre highlight="http">
PUT https://storage.example/data/projects/.shapetree
</pre>
<pre highlight="turtle">
PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
PREFIX ex: &lt;http://www.example/ns/ex#&gt;

&lt;#locator&gt;
  a st:ShapeTreeLocator ;
  st:location <#location1>, <#location2> .
  
<#location1>
  st:hasShapeTree ex:DataCollectionTree ;
  st:hasManagedResource &lt;https://storage.example/data/projects/&gt;
  st:hasRootShapeTreeLocation &lt;https://storage.example/data/.shapetree#location1&gt; ;
  st:node &lt;https://storage.example/data/projects/#collection&gt; ;
  st:shape ex:DataCollectionShape .

<#location2>
  st:hasShapeTree ex:ProjectCollectionTree ;
  st:hasManagedResource &lt;https://storage.example/data/projects/&gt;
  st:hasRootShapeTreeLocation &lt;https://storage.example/data/projects/.shapetree#location2&gt; ;
  st:node &lt;https://storage.example/data/projects/#collection&gt; ;
  st:shape ex:ProjectCollectionShape .
</pre>

<pre highlight="http">
HTTP/1.1 204 No Content
</pre>

### [=Server-side Agent|Server-side=] ### {#plant-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>An HTTP `PUT` or `PATCH` request on `LOCATORURI` from the 
    [[#plant-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

Note: The following sequence is invoked by the server in response 
to the `HTTP PUT` or `HTTP PATCH` on `LOCATORURI` by the [=client-side agent=] 
in the [[#plant-client|previous sequence]].

1. Let `LOCATOR` be the [=shape tree locator=] target of `REQ`
1. Let `R` be the primary resource directly associated with `LOCATOR`
1. Let `ULR` be the updated [=shape tree locator=] in the body of `REQ`
1. Let `ELR` be the existing [=shape tree locator=] resource on the server
1. Let `ADDED` be the set of [=shape tree locations=] that have been added to `ELR` by `ULR`
1. Let `REMOVED` be the set of [=shape tree locations=] that have been removed from `ELR` by `ULR`
1. If `REMOVED` is not empty, the server must [[#unplant-server|unplant]] the
    [=shape tree locations=] that have been removed.
1. For each [=shape tree location=] `LN` in `ADDED`
    1. Call [[#assign-resource]]  with inputs: `ULR`, `LN`, `LN`, `R`, `NULL`

</div>

## Unplant Shape Tree ## {#unplant-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation unassigns a planted 
        [=shape tree=] from a given [=managed resource=]. If the
        [=managed resource=] is a [=managed container=], it will also
        unassign contained resources. 

        This operation will fail immediately if the [=shape tree=] to unplant 
        is not the root [=shape tree location=].
      </td>
  </tbody>
</table>

### [=Client-side Agent|Client-side=] ### {#unplant-client}

<table class="data operation" align="left">
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=managed resource=] to unplant</td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>A URI representing the target shape tree to unplant for `TR`</td>
    </tr> 
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `LOCATOR` be the [=Shape Tree Locator=] returned from [[#discover]] 
    with inputs: `TR`

1. Return failure if `LOCATOR` has zero or more than one
    [=shape tree locations=] where `st:hasShapeTree` is `TST`
   
1. If `LOCATOR` has a single [=shape tree location=]
    1. Perform an HTTP `DELETE` on `LOCATOR` to fully remove the
        [=Shape Tree Locator=] for `TR`

<pre highlight="http">
DELETE https://storage.example/data/projects/.shapetree
</pre>
<pre highlight="http">
HTTP/1.1 204 No Content
</pre>


1. If `LOCATOR` has more than one [=shape tree location=]
    1. Let `LN` be the [=shape tree location=] where `st:hasShapeTree` is `TST`
    1. Perform an HTTP `PUT` or `PATCH` on `LOCATOR` to remove `LN`

</div>

### [=Server-side Agent|Server-side=] ### {#unplant-server}

<table class="data operation" align="left">
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>
        An HTTP PUT, PATCH, or DELETE request on the [=shape tree locator=]
        `LOCATOR` from the [[#unplant-client|previous sequence]].
      </td>
    </tr> 
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

Note: The following sequence is invoked by the server in response
to the `HTTP PUT`, `HTTP PATCH`, or `HTTP DELETE` on `LOCATORURI` by the 
[=client-side agent=] in the [[#unplant-client|previous sequence]].

1. Let `LOCATOR` be the [=shape tree locator=] target of `REQ`
1. Let `R` be the primary resource directly associated with `LOCATOR`
1. Let `ULR` be the updated [=shape tree locator=] in the body of `REQ`
1. Let `ELR` be the existing [=shape tree locator=] resource on the server
1. Let `ADDED` be the set of [=shape tree locations=] that have been added to `ELR` by `ULR`
1. Let `REMOVED` be the set of [=shape tree locations=] that have been removed from `ELR` by `ULR`
1. For each [=shape tree location=] `LN` in `REMOVED`
  1. Call [[#unassign-resource]]  with inputs: `LN`, `R`
1. If `ADDED` is not empty, the server must [[#plant-server|plant]] the
     [=shape tree locations=] that have been added.

</div>

## Create Shape Tree Instance ## {#create-shape-tree-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation creates a [=shape tree instance=] within a 
        [=managed container=].

        Note: This operation can be performed as
        a standard HTTP operation with no knowledge of [=shape trees=].
        However, server-side processing is more efficient when
        the target shape tree and focus node for validation can be provided
        by the [=client-side agent=].
      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#create-instance-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=resource=]</td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>An <em class="rfc2119">OPTIONAL</em> URI representing the target shape 
      tree associated with the created resource</td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>An <em class="rfc2119">OPTIONAL</em> URI representing the target 
      subject within `TR` used for shape validation</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP `POST`, `PUT`, or `PATCH` in or on `TR` to create the
    [=shape tree instance=] including:
    * An HTTP `Link` header with the relation of 
        `http://www.w3.org/ns/shapetrees#TargetShapeTree` if `SHAPETREEURI` is provided
    * An HTTP `Link` header with the relation of 
        `http://www.w3.org/ns/shapetrees#FocusNode` if `FNURI` is provided

</div>

### [=Server-side Agent|Server-side=] ### {#create-instance-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>A HTTP `POST`, `PUT`, or `PATCH` request in or on the [=target resurce=] `TR` 
      from the [[#create-instance-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `TR` be the proposed resource from `REQ`
1. Let `TST` be the value of an optionally provided HTTP `Link` header with 
    the relation of `http://www.w3.org/ns/shapetrees#TargetShapeTree`
1. Let `FN` be the value of an optionally provided HTTP `Link` header with
    the relation of `http://www.w3.org/ns/shapetrees#FocusNode`
1. Let `PC` be the parent [=container=] for `TR`
1. Let `CLN` be the [=shape tree location=] whose [=shape tree=] `CLNST` 
    manages the allowed members of `PC` via `CLNST st:contains`
    1. If `CLN` is not found, the request can be passed through, as the created
        resource `TR` will not be a [=managed resource=]
1. Call [[#validate-contained-resource]] with inputs: `CLNST`, `TR`, `TST`, `FN`
    1. Let `AVR` be the positive validation result returned
1. Create `TR`
1. Call [[#assign-resource]] with inputs: `NULL`, `CLN st:hasShapeTreeRootLocation`, `CLN`, `TR`, `AVR` 

</div>

## Update Shape Tree Instance ## {#update-shape-tree-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation updates an existing [=managed resource=]. 

        Note: This operation can be performed as
        a standard HTTP operation with no knowledge of [=shape trees=].
        However, server-side processing is more efficient when
        the target shape tree and focus node for validation can be provided
        by the [=client-side agent=].
      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#update-instance-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=resource=]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP `PUT` or `PATCH` on an existing resource `TR` to update the
     [=shape tree instance=]
   
</div>

### [=Server-side Agent|Server-side=] ### {#update-instance-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>A HTTP `PUT` or `PATCH` request on the [=managed resource=] 
      from the [[#update-instance-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `TR` be the target resource of `REQ`
1. Let `UR` be the updated version of `TR` in the body of `REQ`
1. Let `LR` be the [=shape tree locator=] associated with `TR`
1. If `LR` exists
    1. For each [=shape tree location=] `LN` in `LR`
        1. Call [[#validate-resource]] with inputs: `LN st:hasShapeTree`, `UR`, `LN st:node` 
1. Update [=resource=] `TR` with `UR`

</div>

## Delete Shape Tree Instance ## {#delete-shape-tree-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation deletes a [=managed resource=] for an existing 
        [=shape tree instance=]. 

        Note: This operation should be performed as
        a standard HTTP operation with no knowledge of [=shape trees=]. It
        is included here for completeness
      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#delete-instance-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=resource=]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP `DELETE` on an existing resource `TR` to delete the
    [=shape tree instance=]

</div>

### [=Server-side Agent|Server-side=] ### {#delete-instance-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>An HTTP `DELETE` request on the [=managed resource=] 
      from the [[#update-instance-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `TR` be the target resource of `REQ`
1. Delete [=resource=] `TR`
    * The [=Shape Tree Locator=] associated with `TR`
        <em class="rfc2119">MUST</em> be removed with `TR`

</div>

Shape Tree Algorithms {#algorithms}
=====================

The following algorithms define a library of functions referenced in the above
[operations](#operations).

## Assign Shape Tree to Resource ## {#assign-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      Assigns the target [=shape tree=] `TST` to the target [=resource=] 
      resource `TR`.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RTLR`</td>
      <td>
        The root [=shape tree locator=] of the planted hierarchy 
      </td>
    </tr>
    <tr>
      <td>`RTLN`</td>
      <td>
        The root [=shape tree location=] of the planted hierarchy 
      </td>
    </tr>
    <tr>
      <td>`PLN`</td>
      <td>
        The parent [=shape tree location=] of the primary resource `R` 
      </td>
    </tr>
    <tr>
      <td>`R`</td>
      <td>
        The primary resource for assignment 
      </td>
    </tr>
    <tr>
      <td>`AVR`</td>
      <td>
        An optional validation result indicating that that `R` has
        already passed validation in advance and does not need this algorithm 
        to perform validation again.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A regular HTTP Response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `ATPLANTROOT` be true if `RTLN st:hasManagedResource` is `R` 
1. If `AVR` is provided
    1. Let `RST` be the [=shape tree=] that `R` has been validated to conform to
    1. Let `RFN` be the focus node for shape validation by `RST st:shape`
1. If `ATPLANTROOT`
    1. Let `RST` be `RTLN st:hasShapeTree`
    1. If `AVR` was not provided call [[#validate-resource]] with inputs: `RST`, `R`, `NULL`
    1. Let `RFN` be the matching focus node provided in the validation result
1. If not `ATPLANTROOT` and `AVR` was not provided
    1. Call [[#validate-contained-resource]] with inputs: `PLN st:hasShapeTree`, `R`, `RST`, `RFN`
    1. Let `RST` be the matching [=shape tree=] provided in the validation result
    1. Let `RFN` be the matching focus node provided in the validation result
1. Let `RLR` be the [=shape tree locator=] associated with `R`
1. Let `RLN` be a new [=shape tree location=] created for `R` with the following  properties:
    * Let `st:hasShapeTree` be `RST`
    * Let `st:hasManagedResource` be `R`
    * Let `st:hasRootShapeTreeLocation` be `RLN`
    * Let `st:node` be `RFN`
    * Let `st:shape` be `RST st:shape`
1. If `R` is a non-empty container, let `CONTAINED` be the set of contained resources
    sorted by type, containers first. 
1. For each contained resource `CR` in `CONTAINED`, starting with containers
    1. Call [[#assign-resource]] with inputs: `RTLR`, `RTLN`, `RLN`, `R`, `NULL`
1. Create or Update the [=Shape Tree Locator=] `RLR`

</div>

## Unassign Shape Tree from Resource ## {#unassign-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2> 
      Unassigns a [=shape tree=] managing resource `R` by removing the
      [=shape tree location=] assigned to `R` for that [=shape tree=].
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RTLN`</td>
      <td>
        The root [=shape tree location=] at the top of the planted
        hierarchy.
      </td>
    </tr>
    <tr>
      <td>`R`</td>
      <td>
        The resource to unplant in the plant hierarchy of `RTLN` 
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A regular HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `RLR` be the [=shape tree locator=] associated with `R`
1. Let `RLN` be the [=shape tree location=] to remove for `R` where 
    `RTLN` is equivalent to `RLN st:hasRootShapeTreeLocation`
1. Let `RLNST` be the [=shape tree=] `RLN st:hasShapeTree`
1. If `R` is a non-empty container, let `CONTAINED` be the set of contained resources
    sorted by type, containers first.
1. For each contained resource `CR` in `CONTAINED`, starting with containers
    1. Call [[#unassign-resource]] with inputs: `RTLN`, `CR`
1. Update or delete the [=Shape Tree Locator=] `RLR`
 
</div>

## Validate Contained Resource ## {#validate-contained-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This algorithm is responsible for determining which [=shape tree=] within a set
        of shape trees mentioned in <code class="vocab">st:contains</code> is
        applicable for a given proposed resource.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`ST`</td>
      <td>
        The validating [=shape tree=]
      </td>
    </tr>
    <tr>
      <td>`R`</td>
      <td>
        The resource to be evaluated against the permitted set of contained 
        [=shape trees=] in `ST st:contains` 
      </td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>
        An <em class="rfc2119">OPTIONAL</em> URI that provides the algorithm 
        with a target shape tree that `R` is expected to conform to. No 
        other [=shape trees=] from `ST st:contains` are considered when provided.
      </td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>
        An <em class="rfc2119">OPTIONAL</em> URI representing the target 
        subject node within `R` used for shape validation.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`VR`</td>
      <td>
        A validation result containing:
        <ul>
          <li>Valid (true or false)</li>
          <li>Validating shape tree `ST`</li>
          <li>Matching shape tree in `ST st:contains`</li>
          <li>Matching shape (if applicable)</li>
          <li>Matching focus node (if applicable)</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. If `TST st:contains` is empty, return a true validation result
1. If `TST` is provided but does not exist in `ST st:contains` return a false validation result
1. If `TST` is provided call [[#validate-resource]] with inputs: `TST`, `R`, `FN`    
1. If `TST` is not provided then for each [=shape tree=] `CST` linked via `ST st:contains`
    1. Call [[#validate-resource]] with inputs: `CST`, `R`, `FN`

</div>

## Validate Resource ## {#validate-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This algorithm is responsible for determining whether a given resource
      conforms with a [=shape tree=]  
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`ST`</td>
      <td>
        The [=shape tree=] that `R` will be evaluated against 
      </td>
    </tr>
    <tr>
      <td>`R`</td>
      <td>
        The resource to evaluate for conformance to `ST` 
      </td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>
        An <em class="rfc2119">Optional</em> focus node to use for shape 
        validation when `TST st:shape` is set 
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`VR`</td>
      <td>
        A validation result containing:
        <ul>
          <li>Valid (true or false)</li>
          <li>Validating shape tree `ST`</li>
          <li>Matching shape (if applicable)</li>
          <li>Matching focus node (if applicable)</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Return a failing validation result if `ST st:expectedType` is set and is not the resource type of `R`
1. Return a failing validation result if `ST rdfs:label` is set and is not equal to the resource name of `R`
1. Return a failing validation result if `ST st:shape` is set and shape validation of the body content of `R` fails
1. Return a positive validation result

</div>

Describing Shape Trees {#describing}
=====================

While the RDF structure of [=shape trees=] enable machine readability, additional
context is needed to make it human-friendly.

External [=SKOS graphs=] can be <em class="rfc2119">OPTIONALLY</em> linked to
describe the shape tree in human-readable terms.

* Let <code>STR</code> be an RDF document containing one or more
    [=shape trees=] <code>STs</code>.
* The { &lt;&gt; <code class="vocab">st:hasShapeTreeDecoratorIndex</code>
    <code>IDX</code> } [=triple=] indicates that there is exactly one
    <code class="vocab">st:ShapeTreeDecoratorIndex</code> located at
    <code>IDX</code>.
* The { <code>IDX</code> <code>a</code>
    <code class="vocab">st:ShapeTreeDecoratorIndex</code> } [=triple=] indicates a
    <code class="vocab">st:ShapeTreeDecoratorIndex</code> that represents an
    index of <code class="vocab">st:ShapeTreeDecoratorSet</code>.
* The { <code>IDX</code> <code class="vocab">st:hasSet</code>
    <code>SET</code> } [=triple=] indicates linkage to one or more
    <code class="vocab">st:ShapeTreeDecoratorSet</code>.
* The { <code>SET</code> <code>a</code>
    <code class="vocab">st:ShapeTreeDecoratorSet</code> } [=triple=] indicates a
    <code class="vocab">st:ShapeTreeDecoratorSet</code> that represents a
    [=SKOS graphs=] for a given language or interpretation.
* The { <code>SET</code> <code class="vocab">st:hasShapeTreeDecoratorResource</code>
    <code>DECRESOURCE</code> } [=triple=] indicates linkage to a single
    <code class="vocab">st:ShapeTreeDecoratorResource</code>.
* The { <code>SET</code> <code class="vocab">st:usesLanguage</code>
    <code>LANG</code> } [=triple=] indicates the language used by the associated
    <code>DECRESOURCE</code>.

<figure id="shapetree-decorator-shex">
  <figcaption>ShEx validation of a Shape Tree Decorators</figcaption>
  <pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
  PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
  PREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;

  &lt;#DecoratorIndex&gt; {
    a [ st:ShapeTreeDecoratorIndex ] ;
    st:defaultLanguage xsd:language ? ;
    st:hasSet IRI*
  }

  &lt;#DecoratorSet&gt; {
    a [ st:ShapeTreeDecoratorSet ] ;
    st:usesLanguage xsd:language ;
    st:hasShapeTreeDecoratorResource IRI
  }

  &lt;#Decorator&gt; {
    a [ st:ShapeTreeDecorator ] ;
    st:hasShapeTree IRI ;
    skos:prefLabel xsd:string ;
    skos:definition xsd:string ?
  }
  
  </pre>
</figure>    

SKOS constructs such as <code>skos:narrower</code> <em class="rfc2119">MAY</em>
  be used to group or organize related [=shape trees=].

Definitions {#definitions}
=====================
Two terms are imported from [[RDF]]:
  * <dfn>triple</dfn> -- an [RDF triple](https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple)
  * <dfn>RDF graph</dfn> -- an [RDF graph](https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple)
        as defined in [[RDF]].

The following terms are used throughout this specification:
  * <dfn>Client-side Agent</dfn> -- A software component interacting with a server.
        A client-side agent will typically rely on the server for shape tree 
        evaluation and/or validation, but may choose to apply it locally
        as well.
  * <dfn>Container</dfn> -- the generalized notion of a collection of resources;
        implementations of [=shape trees=] <em class="rfc2119">MAY</em> use a
        container implementation such as [[LDP]]
        ([ldp:Container](https://www.w3.org/TR/ldp/#dfn-linked-data-platform-container),
        [ldp:BasicContainer](https://www.w3.org/TR/ldp/#dfn-linked-data-platform-basic-container),
        etc.)
  * <dfn>Ecosystem</dfn> -- a software environment with resources organized in
        some hierarchical grouping that rely on [=shape tree=] concepts to
        better organize and validate structures of data
  * <dfn>Focus Node</dfn> -- a node in an [=RDF graph=].  In
        the context of [=shape trees=], one usage is directing [=shape=] validation
        to the appropriate node in an [=RDF graph=].
  * <dfn>Managed Container</dfn> -- any [=managed resource=] that is a 
        [=container=]. A [=Managed Container=] <em class="rfc2119">MAY</em>
        be an [=Instance Root=] or hierarchically nested within the
        resource hierarchy.
  * <dfn>Non-RDF Source</dfn> -- the generalized notion of document not
        containing linked-data triples; this may include
        plain text or binary data.
  * <dfn>Resource</dfn> -- the generalized notion of document containing linked-data;
        implementations of [=shape trees=] may use a resource implementation such
        as [[LDP]] (ldp:Resource, etc.)
  * <dfn>Server-side Agent</dfn> -- A server-side software component.  Server-side
        agents that support shape trees are responsible for data validation and
        maintaining [=shape tree locators=].
  * <dfn>Shape</dfn> -- a schema definition allowing validation of an RDF
        subject.  Example specifications supporting the notion of shapes include 
        [[ShEx]] and [[SHACL]].
  * <dfn>SKOS Graph</dfn> -- an [=RDF graph=] conforming to [[skos-reference]]
        data model.  For purposes of [=shape trees=] a
        [=SKOS Graph=] is used to describe a [=shape tree=] in
        human-readable terms.
  * <dfn>Unmanaged Resource</dfn> -- any [=resource=] which does not have an associated
        [=shape tree=].

  <pre class="biblio">
  {
    "ldp": {
      "href": "https://www.w3.org/TR/ldp/",
      "title": "Linked Data Platform 1.0",
      "authors": [
        "Steve Speicher",
        "John Arwe",
        "Ashok Malhotra"
      ]
    },
    "solid": {
          "href": "https://solidproject.org/TR/protocol",
          "title": "Solid Protocol",
          "authors": [
            "Sarven Capasdisli",
            "Tim Berners-Lee",
            "Kjetil Kjernsmo",
            "Justin Bingham",
            "Ruben Verborgh",
            "Dmitri Zagidulin"]
    },
    "rdf": {
          "href": "https://www.w3.org/TR/rdf11-concepts",
          "title": "RDF 1.1 Concepts and Abstract Syntax",
          "authors": [
            "Richard Cyganiak",
            "David Wood",
            "Markus Lanthaler"
          ]
        },
    "shex": {
      "href": "http://shex.io/shex-semantics/index.html",
      "title": "Shape Expressions Language 2.1",
      "authors": [
        "Eric Prud'hommeaux",
        "Iovka Boneva",
        "Jose Emilio Labra Gayo",
        "Gregg Kellogg"
      ]
    },
    "shexpath": {
      "href": "https://shexspec.github.io/spec/ShExPath",
      "title": "Shape Expressions ShExPath Language",
      "authors": [
        "Eric Prud'hommeaux"
      ]
    }
  }
  </pre>
