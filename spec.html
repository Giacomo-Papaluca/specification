<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
    <title>ShapeTrees Specification</title>
    <script async class="remove" src="//www.w3.org/Tools/respec/respec-w3c-common">
    </script>
    <script class="remove">
      var respecConfig = {
        shortName:      "shapetrees-spec",
        specStatus:     "ED",
        // specStatus:     "WG-NOTE",
        noRecTrack: true,
        edDraftURI:  "https://shapetrees.github.io/specification/spec",
        editors:  [
          { name: "Eric Prud'hommeaux" , w3cid: "2112" },
          { name: "Justin Bingham" }
          { name: "Josh Collins" }
        ],
        cg: "Solid",
        wgURI: "https://www.w3.org/community/solid/",
        // wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/53154/status",
        github: {
          repoURL: "https://github.com/shapetrees/specification",
          branch: "master"
        },
        contributing: [
          "https://github.com/w3c/respec/wiki"
        ]
      };
    </script>
    <style>
      .cross::before { content: "(see primer)"; font-size: small; vertical-align: top; background-color: buttonface }
    </style>
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css"/>
    <link rel="stylesheet" href="local.css"/>
  </head>
  <body>

    <section id="abstract">
      <p>
        Semantic Web Applications interoperate by sharing semantics of terms and constellations of data structures.
        This specification defines Shape Trees, a mechanism for declaring and operating over constellations of data structures.
      </p>
    </section>

    <section id="sotd">
      <p>
        This is a proposal for the structure and use of shape trees in Solid.
        It is possible that this or a derivative document will become a Solid specification.
      </p>
    </section>

    <section id="introduction" class="informative">
      <h2>Introduction</h2>
      <p>
        A Shape Tree defines a tree of related resources which combine to enable some task.
        The shape tree associates each resource with a shape in a schema.
        This document defines the structure and use of Shape trees for [[[LDP]]] [[LDP]] Resources.
      </p>
      <p>
        A shape tree is expressed as an RDF graph structure and the behaviors of agents respecting that graph structure.
        These semantics can be implemented by a server, a client-side library, or a privilenged third-party helper application.
        Communication, including error reporting, is defined in terms of HTTP; allowing a single definition to define the behaviors for servers, clients and third-party applications.
      </p>
    </section>

    <section id="structure">
      <h2>Shape Tree Structure <a class="cross" href="primer#structure"></a></h2>
      <p>
        A <dfn>Shape Tree</dfn> is a machine-readable template describing the expected layout of a tree of LDP Resources in a Pod.
        A Shape Tree links to other Shape Trees to form a resource hierarchy captured by <code>tree:contains</code> links:
      </p>
      <div>
        <pre><code class="shexc">
&lt;#ShapeTree&gt; {
  tree:expectsType [ tree:ShapeTreeContainer tree:ShapeTreeResource tree:ShapeTreeNonRDFResource ] ;
  (rdfs:label xsd:string | tree:matchesUriTemplate xsd:string) ;
  tree:validatedBy IRI ? ;
  tree:supports IRI ? ;
  tree:references @&lt;#ReferencedShapeTree&gt; * ;
  tree:contains @&lt;#ShapeTree&gt;* .
}

&lt;#ReferencedShapeTree&gt; {
  tree:hasShapeTree IRI ;
  tree:traverseViaShapePath xsd:string
}

        </code></pre>
      </div>
      <p>
        The <code>tree:contains</code> property MUST NOT introduce any cycles into the RDF graph.
      </p>
      <p>
        The realization of a <a>shape tree</a> is an <dfn>instance tree</dfn>.
        The the upper-most Container of that tree is an <dfn>instance root</dfn>.
        Let <code>ST</code> be a <a>shape tree</a>; let <code>T</code> be a corresponding <a>instance tree</a><!-- ; let <code>R</code> be its <a>instance root</a> -->.
        For any ShapeTree <code>S</code> linked in <code>ST</code>:
      </p>
      <ul>
        <li>The tree:expectsType arc identifies the type of a corresponding resource <code>R</code> in <code>T</code>.</li>
        <li>An { <code>S</code> <code>rdfs:label</code> <code>L</code> } arc indicates that there is exactly one corresponding Resource <code>R</code> and it has the name <code>L</code>.</li>
        <li>An { <code>S</code> <code>tree:matchesUriTemplate</code> <code>L</code> } arc indicates that there are an arbitrary number of corresponding resources <code>R</code> and each will have a name that matches the URI template [[RFC6570]] <code>L</code>.</li>
        <li>An { <code>S</code> <code>tree:validatedBy</code> <code>Sh</code> } arc indicates that <code>R</code> must have exactly one node which conforms to shape <code>Sh</code>.</li>
        <li>Any { <code>S</code> <code>tree:contains</code> <code>S2</code> } arcs indicate there is a nested ShapeTree and corresponding nested resource <code>R2</code>.</li>
      </ul>
      <p>
        A { <code>tree:hasShapeTreeDecoratorIndex</code> <code>Si</code> } arc indicates the location of an index of SKOS hierarchies that describe <code>ST</code> .
      </p>
        <div class="issue">
          <p>
            The shape above could be more precise, allowing only for <code>tree:contains</code> arcs if the type is a Container:
          </p>
          <pre><code class="shexc">
&lt;#ShapeTree&gt; {
  (
    a [tree:ShapeTreeContainer] ;
    (rdfs:label xsd:string | tree:matchesUriTemplate xsd:string) ;
    tree:contains @&lt;#ShapeTree&gt; +
  |
    a [tree:ShapeTreeResource tree:ShapeTreeNonRDFResource] ;
    tree:matchesUriTemplate xsd:string
  ) ;
  tree:references @&lt;#ReferencedShapeTree&gt; * ;
  tree:validatedBy IRI ? ;
}

&lt;#ReferencedShapeTree&gt; {
  tree:hasShapeTree IRI ;
  tree:traverseViaShapePath xsd:string
}
          </code></pre>
          <p>Is that too meticulous?</p>
        </div>
        </li>
      </ul>
    </section>

    <section id="terms">
      <h2>Terms</h2>
      <p>
        The following types and functions are used throughout this specification:
      </p>
      <ul>
        <li>types:
        <ul>
          <li><dfn>Container</dfn> -- a [[[LDP]]] [[LDP]] Container</li>
          <li><dfn>Managed Container</dfn> -- any LDP Container in a <a>Planted ShapeTree</a>. A Managed Container may be an <a>Instance Root</a> or hierarchically nested within the resource hierarchy.</li>
          <li><dfn>Unmanaged Container</dfn> -- any LDP Container which is not described by a Shape Tree</li>
          <li><dfn>Supported RDF Format</dfn> -- a textual representation of an RDF graph in a format that can be accurately and losslessly parsed to that RDF graph.</li>
          <li><dfn>Body Graph</dfn> -- the RDF graph derived from parsing the body of an HTTP request with a parser determined by the Content-type: header of that HTTP request.</li>
          <li><dfn>Static Container</dfn> -- an LDP Container which is implied by the existence of the parent resource, denoted by a rdfs:label predicate.</li>
          <li><dfn>Resource Graph</dfn> -- an RDF graph obtained by parsing the body of a GET on an LDP Resource.</li>
          <li><dfn>SKOS Graph</dfn> -- an RDF graph conforming to [[[skos-reference]]] [[skos-reference]] data model
        </ul>
        </li>
        <li>functions:
        <ul>
          <li><dfn>instantiate (resource, contents)</dfn> --
          <ul>
            <li>Make <code>contents</code> available by GET request to <code>resource</code>.</li>
            <li>Let <code>parent</code> be the result of resolving the relative URL <code>..</code> against <code>resource</code>.<br/>
            Add the triple {<code>parent</code> ldp:contains <code>resource</code>} to <code>parent</code>.</li>
          </ul>
          </li>
        </ul>
        </li>
      </ul>
    </section>

    <section id="plant">
      <h2>Planting a Shape Tree <a class="cross" href="primer#creating"></a></h2>
      <p>
        Creating a new shape tree container starts with a POST P to a Regular Container <code>parent</code> to establish the Shape Tree <a>Instance Root</a> with a request body Content-type of some supported RDF Format and one or more Link header with a rel="ShapeTree".
        The <a>Instance Root</a> and <b>nested Static Containers</b> are created by applying <a>instantiate static</a>(<code>F</code>, ".")
      </p>
    </section>

    <section>
      <h2>Navigating Planted Shape Trees</h2>
      <p>
        The Shape Tree describes data instances which are resource hierarchies in an LDP Container hierarchy.
        Every Managed Container has metadata that expresses "where" that managed container is located in reference to the Instance Root of the planted Shape Tree:
      </p>
      <ul>
        <li><b>Shape Tree Instantiation Root</b> &mdash; the IRI of the container that represents the planted Shape Tree .</li>
        <li><b>Shape Tree Instantiation Path</b> &mdash; a relative IRI identifying a location within a shape tree instance. This is represented in RDF as a string literal.</li>
        <li><b>Root Shape Tree</b> &mdash; the IRI of the planted Shape Tree's subject</li>
        <li><b>Current Shape Tree</b> &mdash; a location within a shape tree identified by the IRI of the subject node of that Shape Tree in the shape tree hierarchy.</li>
      </ul>
      <p>
        <dfn>instantiate static</dfn> (<code>shapeTreeInstantiationShapeTree</code>, <code>shapeTreeS</code>) instantiates the Static Containers implied by shapeTreeInstantiationShapeTree <a class="excode" href="https://github.com/shapetrees/specification/blob/master/util/shapetree.js#L309-L331"></a>
      </p>
      <ol>
        <li>
          <p>
            instantiate a <b>shape tree instance</b> &mdash; an LDP Container with a Resource Graph conformant to <span class="hljs-name">&lt;#ShapeTreeInstanceStep&gt;</span> below:
          </p>
          <div>
            <pre><code class="shexc">
&lt;#ShapeTreeInstanceStep&gt; {
  a [tree:ShapeTreeLocator] ;
  dc:title xsd:string;
  tree:shapeTreeRoot IRI;
  tree:shapeTreeInstancePath xsd:string;
  tree:shapeTreeInstanceRoot IRI;
  tree:hasShapeTree IRI;
  ldp:contains IRI *.
}
            </code></pre>
          </div>
        </li>
        <li>for each <code>child shape tree</code> in { <code>shapeTreeInstantiationShapeTree</code>, tree:contains, * }
          <ul>
            <li>if <code>child shape tree</code> has an rdfs:label <code>container label</code>
            <ul>
              <li>apply <a>instantiate static</a>(<code>child shape tree</code>, path.join(<code>shapeTree</code>, <code>container label</code>))</li>
            </ul>
            </li>
          </ul>
        </li>
      </ol>
    </section>

    <section id="post-managed">
      <h2>Creating Data Instances <a class="cross" href="primer#updating"></a></h2>
      <p>
        For any POST, PUT, PATCH <code>P</code> to any Managed Container <code>parent</code>:
      </p>
      <ol>
        <li>If <code>P</code> does not have a Link: header with rel="focusNode" and href=<code>H</code>, the request is rejected with a status code of 400.</li>
        <li>Let <code>N</code> be <code>H</code> resolved against he base of parent's URL overloaded by any BASE or PREFIXes defined in the Resource Body.</li>
        <li>Let <code>RG</code> be the container's Resource Graph.</li>
        <li>Let <code>IR</code> be the Shape Tree Instantiation Root.</li>
        <li>Let <code>IP</code> be the Shape Tree Instantiation Path.</li>
        <li>Let <code>IS</code> be the Shape Tree Instantiation Step found by following IP through the Shape Tree hierarchy.</li>
        <li>Let <code>S</code> be the the tree:validatedBy included in IS.</li>
        <li>Let <code>R</code> be the results of validating the ShapeMap <code>N@S</code>.</li>
        <li>If <code>R</code> is an error, the request is rejected with a status code of 422 (Unprocessable Entity).</li>
        <li>Otherwise the Pod creates a new entity <code>Name</code>, where name may have been influenced by the Slug: header:
        <ul>
          <li>If <code>P</code> has a Link: header with rel="type" and href=ldp:Container,
          <ul>
            <li><b>nested Static Containers</b> are created by applying <a>instantiate static</a>(<code>F</code>, <code>IP</code> + "/" + <code>Name</code>))</li>
          </ul>
          </li>
          <li>The request is processed according to POST/PUT/PATCH to an [[!LDP]] Container.</li>
        </ul>
        </li>
      </ol>
    </section>

    <section id="describing-shapetrees">
      <h2>Describing Shape Trees <a class="cross" href="primer#describing"></a></h2>
      <p>
        External graphs adhering to the SKOS data model can be optionally used to describe the Shape Tree in human-readable terms.

        Specifying a <code>tree:hasShapeTreeDecoratorIndex</code> predicate within Shape Tree definition enables clients to discover available human-readable definitions of that Shape Tree.
      </p>
    </section>


    <section id="conformance">
    </section>

    <script src="http://www.w3.org/2019/Talks/1209-swat4ls-egp/highlight.pack.js"></script>
    <script src="http://www.w3.org/2019/Talks/1209-swat4ls-egp/highlight-shexc.js"></script>
    <!-- <script src="WWW/2019/Talks/1209-swat4ls-egp/highlight-shexc.js"></script> -->
    <script>
      // TODO: add ShEx highlighter to respec
      hljs.registerLanguage('shexc', hljsDefineShExC);
      hljs.registerLanguage('turtle', hljsDefineTExpr);
      (['DOMContentLoaded', 'load']).forEach(e => addEventListener(e, init, false));
      let inited = false;

      function hljsDefineTExpr (highlightjs) { // works pretty well for Turtle.
        const ret = hljsDefineShExC(highlightjs, 'tripleConstraint');
        ret.disableAutodetect = true;
        return ret;
      }

      function init () {
        if (inited) return;
        inited = true;
        ([400, 800, 1600, 3200, 6400]).forEach(
          tOut => setTimeout(highlightAll, tOut)
        )
      }

      function highlightAll () {
        console.log(new Date())
        try {
          const blocks = document.querySelectorAll('.shexc,.turtle');
          [].forEach.call(blocks, (b) => {
            hljs.highlightBlock(b);
          });
        } catch (e) {}
      }
    </script>
  </body>
</html>
