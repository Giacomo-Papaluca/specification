<pre class="metadata">
Title: Shape Trees Specification
Shortname: shapetrees-spec
Level: 1
Max ToC Depth: 2
Status: w3c/ED
Group: w3c
URL: https://shapetrees.org/spec
Editor: Eric Prud'hommeaux
Editor: Justin Bingham
Editor: Josh Collins
Markup Shorthands: markdown yes
Abstract:
    Semantic Web Applications interoperate by sharing semantics of terms and constellations of data structures.
    This specification defines shape trees, a mechanism for declaring and operating over constellations of data structures.
</pre>

<!-- For bikeshed style overrides -->
<style>

  a[href*=".ttl"] {
    color: #339966;
    border-bottom: 1px solid #339966;
  }

  a[href*=".shex"] {
    color: #cc2900;
    border-bottom: 1px solid #cc2900;
  }

  a[href*=".tree"] {
    color: #e68a00;
    border-bottom: 1px solid #e68a00;
  }

  table.algorithmparams {
    align: center;
  }

  table.algorithmparams tbody td {
    padding-left: 10px;
    padding-right: 50px;
  }

  table.algorithmparams tbody tr:nth-child(even) {
    background-color: lightgray;
  }


  table.algorithmparams thead td {
    padding-left: 10px;
    padding-right: 50px;
  }


  table.operationdetails {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 25px;
  }

  table.operationdetails tbody tr:nth-child(even) {
    background-color: lightgray;
  }

  table.operationdetails thead td {
    padding-left: 10px;
    padding-right: 10px;
    border: 1px solid #999999;
  }

  table.operationdetails tbody td {
    padding-left: 10px;
    padding-right: 10px;
    border: 1px solid #999999;
  }

	code.container {
		color: #005555;
	}

	code.notes {
		color: #770033;
	}

	code.citation {
		color: #330077;
	}

	code.image {
		color: #337700;
	}
</style>

Introduction {#introduction}
=====================
Realizing the value proposition of the Semantic Web lies in building useful and robust applications that can interoperate over linked data.
Protocols such as [[LDP]] and Solid organize linked data graphs into resource hierarchies, providing a foundation upon which these robust and interoperable applications can be created.

Application interoperability depends on applications sharing semantics for relationships and data structures.  Existing technologies fulfill portions of those dependencies:
* RDF&apos;s foundation in unambiguous identifiers provides an infrastructure that allows for interoperability, but does not specifically encouraging or enforce it.
* Shape languages (e.g. ShEx and [[SHACL]]) provide machine-readable, enforceable data structure definitions on single resources.

For applications that operate on more interconnected resources, *Shape Trees* express the layout of those resources and associate them with their respective shapes.

Shape trees marry RDF vocabularies, shapes, and resources into "little trees" that provide machine to machine interoperability,
while at the same time creating concepts that humans can easily comprehend, such as medical records, notes, notebooks,
calendars, and financial records.

This allows one to treat a set of related resources as a single grouping, and apply that to a range of operations including access control,
data organization, data validation, and data migration.

Shape trees are defined as an RDF graph structure that expresses a set of expected behaviors by agents that work with them.
These semantics can be implemented by a server or a client-side library that proxies requests to a server.

This document describes shape trees assuming the usage of a Solid and [[LDP]] environment.

Structure {#structure}
=====================
A <dfn>shape tree</dfn> is a machine-readable template describing the expected layout of a tree of Resources in a Pod.
A shape tree links to other shape trees to form a resource hierarchy captured by <code>tree:contains</code> links:

<figure id="shapetree-shex">
  <figcaption>ShEx validation of a Shape Tree</figcaption>
	<pre highlight="turtle">
  prefix tree: &lt;http://www.w3.org/ns/shapetree#&gt;.
  prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.
  prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.

	&lt;#ShapeTree&gt; {
    a tree:ShapeTree ;
	  (
	    tree:expectsType [tree:ShapeTreeContainer] ;
	    tree:contains @&lt;#ShapeTree&gt; +
	  ) ;
    (rdfs:label xsd:string | tree:matchesUriTemplate xsd:string) ;
	  tree:references @&lt;#ReferencedShapeTree&gt; * ;
	  tree:validatedBy IRI ? ;
    tree:contains IRI ? ;
	}

	&lt;#ReferencedShapeTree&gt; {
	  tree:hasShapeTree IRI ;
	  tree:traverseViaShapePath xsd:string
	}
	</pre>
</figure>

The <code>tree:contains</code> property MUST NOT introduce any cycles into the RDF graph.

The realization of a <a>shape tree</a> is a <dfn>planted shape tree</dfn>.
The the upper-most Container of that tree is the <dfn>instance root</dfn>.
Let <code>ST</code> be a <a>shape tree</a>;
Let <code>T</code> be a corresponding <a>instance tree</a>.
For any shape tree <code>S</code> linked in <code>ST</code>:

* The tree:expectsType arc identifies the type of a corresponding resource <code>R</code> in <code>T</code>.
* An { <code>S</code> <code>rdfs:label</code> <code>L</code> } arc indicates that there is exactly one corresponding Resource <code>R</code> and it has the name <code>L</code>.
* An { <code>S</code> <code>tree:matchesUriTemplate</code> <code>L</code> } arc indicates that there are an arbitrary number of corresponding resources <code>R</code> and each will have a name that matches the URI template [[RFC6570]] <code>L</code>.
* An { <code>S</code> <code>tree:validatedBy</code> <code>Sh</code> } arc indicates that <code>R</code> must have exactly one node which conforms to shape <code>Sh</code>.
* Any { <code>S</code> <code>tree:contains</code> <code>S2</code> } arcs indicate there is a nested shape tree and corresponding nested resource <code>R2</code>.

A { <code>tree:hasShapeTreeDecoratorIndex</code> <code>Si</code> } arc indicates the location of an index of SKOS hierarchies that describe <code>ST</code>

Ecosystems {#ecosystems}
=====================
Shape trees are meant to be used in context of a broader [=ecosystem=].  [=Ecosystems=] have the ability to react to (and in some narrow cases influence) shape tree operations.

Ecosystems are helpful for use cases such as indexing the location of [=plant=]ed [=shape trees=].

Shape tree client libraries should be initialized with a reference to the the target ecosystem it should operate within.

For purposes of this specification, an ecosystem should be considered a software interface, expecting the following operations to be implemented.

## Ecosystem Operations ## {#ecosystem-operations}

### Get Existing Shape Tree ### {#ecosystem-getexistingshapetree}
<code><b>getExistingShapeTreeFromContainer(context:ShapeTreeContext, parentContainer:URI, shapeTreesToPlant:ShapeTree[], resourceName:String) : ShapeTreeLocator</b></code>

This operation allows the [=ecosystem=] to provide shape tree with a previously planted shape tree location.

### Before Plant Shape Tree ### {#ecosystem-beforeplantshapetree}
<code><b>beforePlantShapeTree</b>(context:ShapeTreeContext, targetContainer:URI, bodyGraph:Graph, shapeTreesToPlant:ShapeTree[], linkHeaders:Map) : Graph</code>

This operations allows the [=ecosystem=] to manipulate the the [=body graph=] of a [=Plant=] operation request.

### Index Shape Tree ### {#ecosystem-indexshapetree}
<code><b>indexShapeTree</b>(context:ShapeTreeContext, parentContainer:URI, shapeTree:URI, targetContainer:URI) </code>

This operation notifies the [=ecosystem=] of a new [=shape tree=] being planted.

### Index Shape Tree Data Instance ### {#ecosystem-indexshapetreedatainstance}
<code><b>indexShapeTreeDataInstance</b>(context:ShapeTreeContext, parentContainer:URI, shapeTree:URI, shapeTreeInstance:URI)</code>

This operations notifies the [=ecosystem=] of a new [=shape tree data instance=] being created.

### Unindex Shape Tree ### {#ecosystem-unindexshapetree}
<code><b>unIndexShapeTree</b>(context:ShapeTreeContext, parentContainer:URI, shapeTree:URI, targetContainer:URI) </code>

This operation notifies the [=ecosystem=] of a [=shape tree=]/[=managed container=] being deleted.

### Unindex Shape Tree Data Instance ### {#ecosystem-unindexshapetreedatainstance}
<code><b>unIndexShapeTreeDataInstance</b>(context:ShapeTreeContext, shapeTree:URI, shapeTreeInstance:URI) </code>

This operation notifies the [=ecosystem=] of a [=shape tree data instance=] being deleted.

Note: The <code><b>ShapeTreeContext</b></code> class is implementation specific and may be used to include important context such as authentication details, base URLs, etc.

Shape Tree Operations {#operations}
=====================

Working with shape trees entails using several higher-level operations -- each of which may represent one or more HTTP requests and/or processing logic.

The key operations used to manage shape trees are:
* [Discover Shape Tree](#discover)
* [Plant](#plant)
* [Create Date Instance](#create-data-instance)
* Delete Data Instance

These operations may make use of reusable, internal algorithms defined in [Shape Tree Algorithms](#algorithms).

## Discover Shape Tree ## {#discover}

Note: A Discover Shape Tree operation will be performed by a client-side agent.

The discover shape tree operation entails discovering what, if any, shape trees are managing a given container.

### Inputs ### {#discover-inputs}
* Let <code>uri</code> be the URI of the resource to discover shape trees for

### Outputs ### {#discover-outputs}
* Collection of tree:ShapeTreeLocator subjects

### Operation Summary ### {#discover-summary}

<table class="operationdetails" align="left">
	<thead>
		<tr>
			<th>#</th>
			<th>Step</th>
			<th>Request</th>
			<th>Response</th>
    </tr>
	</thead>
	<tbody>
		<tr>
			<td>[1](#discovery-details-head)</td>
			<td>Perform a HEAD on <code>uri</code> to discover Shape Tree metadata URI</td>
			<td>[Request](#fig-discover-head-request)</td>
			<td>
				[Response](#fig-discover-head-response)
			</td>
		</tr>
		<tr>
			<td>[2](#discovery-details-get)</td>
			<td>Perform a GET on the discovered Shape Tree metadata resource</td>
			<td>[Request](#fig-discover-get-metadata)</td>
			<td>
				[Managed Response](#fig-discover-head-response-managed)<br/>
				[Unmanaged Response](#fig-discover-head-response-unmanaged)
			</td>
		</tr>
		<tr>
			<td>[3](#discovery-details-collect)</td>
			<td>Collect any navigable shape trees</td>
			<td colspan="2">N/A - Logic only</td>
		</tr>
	</tbody>
</table>

See [below](#discovery-details) for more details. <!-- This line isn't especially useful, but bikeshed messes up the links in the above table without some content below it -->

### Operation Details ### {#discovery-details}

#### Perform a HEAD on the provided <code>uri</code> to discover Shape Tree metadata URI #### {#discovery-details-head}
	<figure id="fig-discover-head-request">
		<figcaption>Discover Container Shape Tree Metadata - HEAD container - Request</figcaption>
		<pre highlight="http">
		HEAD /data/CommonNotes/
		</pre>
	</figure>

	<figure id="fig-discover-head-response">
		<figcaption>Discover Container Shape Tree Metadata - HEAD container - Response</figcaption>
		<pre highlight="http">
		HTTP/1.1 200 OK
		Link: &lt;/data/CommonNotes/.shapetree&gt;; rel="http://shapetrees.org/#ShapeTree"
    Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel="type"
		...other headers omitted...
		</pre>
	</figure>

  As discovering shape trees only apply to URIs of containers, if there exists no value of ldp:Container within the Link headers with relation "type", return a 400 status code.

	Let <code>metauri</code> be the URI of the shape tree metadata resource pertaining to <code>uri</code> through the Link header with relation "http://shapetrees.org/#ShapeTree".

#### Perform a GET on the discovered Shape Tree metadata resource (<code>metauri</code>) #### {#discovery-details-get}
	<figure id="fig-discover-get-metadata">
		<figcaption>Discover Container Shape Tree Metadata - Get Shape Tree metadata - Request</figcaption>
		<pre highlight="http">
		GET /data/CommonNotes/.shapetree
		</pre>
	</figure>

	<figure id="fig-discover-head-response-managed">
		<figcaption>Discover Container Shape Tree Metadata - GET Shape Tree metadata - Managed Container Response</figcaption>
		<pre highlight="turtle">
		prefix tree: &lt;http://www.w3.org/ns/shapetree#&gt;.
    prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.
    prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.

		&lt;#shapetree&gt;
	  	tree:hasShapeTreeLocator &lt;#bc1b490a-537d-4749-b778-cd7d6da3ac56&gt; .

		&lt;#bc1b490a-537d-4749-b778-cd7d6da3ac56&gt;
			a tree:ShapeTreeLocator ;
	  	tree:hasRootShapeTree &lt;http://commonnote.example/CommonNoteShapeTree#container&gt; ;
	  	tree:hasShapeTree &lt;http://commonnote.example/CommonNoteShapeTree#container&gt; ;
	  	tree:hasShapeTreeInstancePath "." ;
	  	tree:hasShapeTreeInstanceRoot &lt;/data/CommonNotes/&gt; .
		</pre>
	</figure>

	<figure id="fig-discover-head-response-unmanaged">
		<figcaption>Discover Container Shape Tree Metadata - GET Shape Tree metadata - Unmanaged Container Response</figcaption>
		<pre highlight="http">
		HTTP/1.1 404 NOT FOUND
		</pre>
	</figure>

	If a 404 is returned that indicates that no shape trees manage this container, and as such can be considered an [=Unmanaged Container=].

#### Collect any navigable shape trees #### {#discovery-details-collect}
	If the <#shapetree> subject has one or more tree:hasShapeTreeLocator predicates it means this container should be considered a [=Managed Container=].

	The tree:hasShapeTree of each tree:ShapeTreeLocator instance specifies a shape tree managing this container, the URI of each shape tree will be returned.

## Plant ## {#plant}

Note: A plant operation can be performed by either a client or server side agent.

The plant operation represents the act of marking a container (new or existing) as being managed by one or more shape trees.

### Inputs ### {#plant-inputs}
* Let <code>req</code> be a POST or PUT HTTP request with the following characteristics:
	* Let <code>linkst</code> be one or more Link headers with the relation of "http://shapetrees.org/#ShapeTree".  This represents one or more shape trees to be planted by the plant operation.
	* A Link header with the relation "type" and a value of &lt;http://www.w3.org/ns/ldp#BasicContainer&gt;
	* Let <code>linkfn</code> be an optional Link header with the relation of "http://shapetrees.org/#FocusNode".  This represents the target subject within the request body to start validation, when validating using ShEx.
	* Let <code>linktst</code> be an optional Link header with the relation of "http://shapetrees.org/#TargetShapeTree"
  * Let <code>slug</code> be a Slug header, required when <code>req</code> is a POST
  * Let <code>name</code> be a portion of the URI that represents the name of the resource, will only be present with <code>req</code> is a PUT

### Outputs ### {#plant-outputs}
* An HTTP response containing a Location header with the URI of the container that the requested shape trees (<code>linkst</code>) are planted in

### Key Terms for Planting ### {#plant-keyterms}
	* Let <code>pc</code> be the <dfn>Parent Container</dfn> - The container that will contain the new or existing container representing the planted shape tree.  When <code>req</code> is a POST, this will be the location URL.  For PUT, this will be the parent of the PUT container.
	* Let <code>tc</code> be the <dfn>Target Container</dfn> - The container that will contain instances of the planted shape tree.  This container may or may not already exist.

### Operation Summary ### {#plant-summary}

<table class="operationdetails" align="left">
	<thead>
		<tr>
			<th>#</th>
			<th>Step</th>
			<th>Request</th>
			<th>Response</th>
    </tr>
	</thead>
	<tbody>
    <tr>
      <td>[1](#plant-details-callhook-beforeplantshapetree)</td>
      <td>Call Ecosystem Hook - Before Plant Shape Tree</td>
      <td colspan="2">See [Before Plant Shape Tree](#ecosystem-beforeplantshapetree)</td>
    </tr>
		<tr>
			<td>[2](#plant-details-preconditions)</td>
			<td>Preconditions:
				* Discover Shape Tree(s) for Parent Container (<code>pc</code>)
				* Discover Shape Tree(s) for Target Container (<code>tc</code>)
			</td>
			<td colspan="2">See [Discovery](#discover)</td>
		</tr>
		<tr>
			<td>[3](#plant-static-validation)</td>
			<td>Static Validation of Shape Trees for Conflicts</td>
			<td colspan="2">N/A - Logic only</td>
		</tr>
		<tr>
			<td>[4](#plant-graphbody-validation)</td>
			<td>Validate Graph Body</td>
			<td colspan="2">N/A - Logic only</td>
		</tr>
		<tr>
			<td>[5](#plant-parent-validation)</td>
			<td>Validate against parent container</td>
			<td colspan="2">See [Validate Proposed Resource](#validate-proposed-resource)</td>
		</tr>
		<tr>
			<td>[6](#plant-create-container)</td>
			<td>Create Target Container (<code>tc</code>), if necessary</td>
			<td>[Request](#fig-plant-create-target-request)</td>
			<td>[Response](#fig-plant-create-target-response)</td>
		</tr>
		<tr>
			<td>[7](#plant-update-container-metadata)</td>
			<td>Update Shape Tree Meta Data for Target Container (<code>tc</code>)</td>
			<td colspan="2">See [Update Container Metadata](#update-container-metadata)</td>
		</tr>
		<tr>
			<td>[8](#plant-initialize-statics)</td>
			<td>Initialize Static Content</td>
			<td colspan="2">See [Initialize Static Content](#initialize-statics)</td>
		</tr>
    <tr>
			<td>[9](#plant-details-callhook-indexshapetree)</td>
			<td>Call Ecosystem Hook - Index Shape Tree</td>
			<td colspan="2">See [Index Shape Tree](#ecosystem-indexshapetree)</td>
		</tr>
	</tbody>
</table>

See [below](#plant-details) for more details. <!-- This line isn't especially useful, but bikeshed messes up the links in the above table without some content below it -->

### Operation Details ### {#plant-details}

#### Call Ecosystem Hook - Before Plant Shape Tree #### {#plant-details-callhook-beforeplantshapetree}
1. Call the provided [=ecosystem=]'s [Before Plant Shape Tree operation](#ecosystem-beforeplantshapetree) with parameters:

  <table class="algorithmparams">
    <thead>
      <tr>
        <td><b>Parameter</b></td>
        <td><b>Value</b></td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>targetContainer</code></td>
        <td><code>tc</code></td>
      </tr>
      <tr>
        <td><code>bodyGraph</code></td>
        <td>
          [=Body Graph=] of <code>req</code>
        </td>
      </tr>
      <tr>
        <td><code>shapeTreesToPlant</code></td>
        <td><code>linkst</code></td>
      </tr>
      <tr>
        <td><code>linkHeaders</code></td>
        <td>Link headers of <code>req</code></td>
      </tr>
  </table>

#### Preconditions #### {#plant-details-preconditions}
1. Ensure the [=Parent Container=] (<code>pc</code>) exists.  If not, return a 404 status code.
1. [Discover](#discover) any planted shape tree IRIs managing <code>pc</code>.
	1. Let <code>parentst</code> be the collection of dereferenced shape tree IRIs discovered for <code>pc</code>
1. If the [=Target Container=] (<code>tc</code>) already exists, [discover](#discover) any previously planted shape tree IRIs.
	1. Collect any existing shape tree IRIs and combine with the IRIs of the <code>linkst</code> provided via the request Link header to represent the full collection of existing and proposed shape trees for <code>tc</code>.
	1. Let <code>allst</code> be the collection of dereferenced shape tree IRIs representing both existing and <code>linkst</code> IRIs

#### Static Validation of Shape Trees for Conflicts #### {#plant-static-validation}
1. Iterate <code>allst</code> to validate that none of the following conditions are met:
	* any shape tree has a tree:expectsResourceType with a value other than tree:ShapeTreeContainer
	* more than one shape tree has a tree:validatedBy value
	* more than one shape tree has a tree:contains value

If any of the above static validations fail, return a 400 status code.

#### Validate graph body #### {#plant-graphbody-validation}

Issue: Must detail how to differentiate between ShEx and SHACL validation

1. Let <code>vst</code> be the validating shape tree that is identified by the only shape tree in <code>allst</code> having a tree:validatedBy value
1. If <code>vst</code> is present and the plant operation (<code>req</code>) includes an RDF graph body and ShEx validation is used and a [=Focus Node=] (<code>linkfn</code>) is not present, return a 422 status code
1. Perform a validation of the RDF graph body of <code>req</code> using the <code>vst</code> tree:validatedBy shape, targeting the graph's <code>linkfn</code>.  If validation fails, return a 422 status code

#### Validate against parent container #### {#plant-parent-validation}
1. Determine if the [=Parent Container=] (<code>pc</code>) is a [=Managed Container=] by evaluating if <code>parentst</code> is not empty
2. If <code>pc</code> is a [=Managed Container=] call the [validate proposed resource](#validate-proposed-resource) algorithm with parameters:

  <table class="algorithmparams">
    <thead>
      <tr>
        <td><b>Parameter</b></td>
        <td><b>Value</b></td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>uri</code></td>
        <td><code>pc</code></td>
      </tr>
      <tr>
        <td><code>rn</code></td>
        <td>
          If <code>req</code> is a POST then <code>slug</code><br/>
          If <code>req</code> is a PUT then <code>name</code>
        </td>
      </tr>
      <tr>
        <td><code>sth</code></td>
        <td><code>linktst</code></td>
      </tr>
      <tr>
        <td><code>rt</code></td>
        <td>Container</td>
      </tr>
  </table>

#### Create Target Container (<code>tc</code>), if necessary #### {#plant-create-container}
1. If <code>tc</code> does not exist, create it.

	<figure id="fig-plant-create-target-request">
		<figcaption>Create Target Container - Request</figcaption>
		<pre highlight="http">
		POST /<b><i>&lt;pc&gt;</b></i>/
		Slug: <b><i>&lt;tc&gt;</b></i>;
		Link: &lt;http://www.w3.org/ns/ldp#BasicContainer&gt;; rel="type"
		</pre>
	</figure>

	<figure id="fig-plant-create-target-response">
		<figcaption>Create Target Container - Response</figcaption>
		<pre highlight="http">
		HTTP 201 CREATED
		Location: http://pod.example/<b><i>&lt;pc&gt;</b></i>/<b><i>&lt;tc&gt;</b></i>/
		Content-type: text/turtle; charset=utf-8
		Content-length: 396
		</pre>
	</figure>


#### Update Shape Tree Meta Data for Target Container (<code>tc</code>) #### {#plant-update-container-metadata}
1. Update Target Container <code>tc</code> Metadata (<code>metauri</code>)

	1. Iterate the collection of shape trees to be planted (<code>linkst</code>), let <code>linksti</code> be the current shape tree in context.
	1. Call algorithm [Update Container Metadata](#update-container-metadata) with parameters:

	<table class="algorithmparams">
		<thead>
			<tr>
				<td><b>Parameter</b></td>
				<td><b>Value</b></td>
			</tr>
		</thead>
		<tbody>
      <tr>
        <td><code>tc</code></td>
        <td><code>tc</code></td>
			<tr>
				<td><code>rootst</code></td>
				<td><code>linksti</code></td>
			</tr>
			<tr>
				<td><code>st</code></td>
				<td><code>linksti</code></td>
			</tr>
			<tr>
				<td><code>ip</code></td>
				<td>"."</td>
			</tr>
			<tr>
				<td><code>rootpath</code></td>
				<td><code>tc</code></td>
			</tr>
	</table>

#### Initialize Static Content #### {#plant-initialize-statics}
1. Let <code>cst</code> be the shape tree having a tree:contains value (if one exists) from the list of shape trees that were planted <code>linkst</code>
1. Iterate any tree:contains IRIs within <code>cst</code>, letting <code>csti</code> be the current IRI in context
1. Let <code>cstist</code> be the shape tree resulting in dereferencing IRI <code>csti</code>
1. If <code>cstist</code> has a rdfs:label value, call algoritm [Initialize Statics](#initialize-statics) with parameters:

  Let <code>label</code> be the value of rdfs:label for <code>cstist</code>

  <table class="algorithmparams">
    <thead>
      <tr>
        <td><b>Parameter</b></td>
        <td><b>Value</b></td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>pc</code></td>
        <td><code>tc</code></td>
      <tr>
        <td><code>sst</code></td>
        <td><code>cstist</code></td>
      </tr>
      <tr>
        <td><code>rst</code></td>
        <td><code>cst</code></td>
      </tr>
      <tr>
        <td><code>rc</code></td>
        <td><code>tc</code></td>
      </tr>
      <tr>
        <td><code>d</code></td>
        <td><code>0</code></td>
      </tr>
  </table>

#### Call Ecosystem Hook - Index Shape Tree #### {#plant-details-callhook-indexshapetree}
1. Iterate the collection of shape trees that were planted (<code>linkst</code>), letting <code>linksti</code> be the current IRI in context
1. Call the provided [=ecosystem=]'s [Index Shape Tree operation](#ecosystem-indexshapetree) with parameters:

  <table class="algorithmparams">
    <thead>
      <tr>
        <td><b>Parameter</b></td>
        <td><b>Value</b></td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>parentContainer</code></td>
        <td><code>pc</code></td>
      </tr>
      <tr>
        <td><code>shapeTree</code></td>
        <td><code>linksti</code></td>
      </tr>
      <tr>
        <td><code>targetContainer</code></td>
        <td><code>tc</code></td>
      </tr>
  </table>

## Create Data Instance ## {#create-data-instance}

Note: A Create Data Instance operation can be performed by either a client or server side agent.

The create data instance operation is the act of creating an instance of a shape tree within a managed container.

### Inputs ### {#create-data-instance-inputs}
* Let <code>req</code> be a POST or PUT HTTP request with the following characteristics:
	* Let <code>linkfn</code> be an optional Link header with the relation of "http://shapetrees.org/#FocusNode".  This represents the target subject within the request body to start validation, when validating using ShEx.
	* Let <code>linktst</code> be an optional Link header with the relation of "http://shapetrees.org/#TargetShapeTree"
  * Let <code>slug</code> be a Slug header, required when <code>req</code> is a POST
  * Let <code>name</code> be a portion of the URI that represents the name of the resource, will only be present with <code>req</code> is a PUT

### Outputs ### {#create-data-instance-outputs}
* Standard HTTP response

### Key Terms for Creating Data Instances ### {#create-data-instance-terms}
* Let <code>pc</code> be the [=Parent Container=]

### Operation Summary ### {#create-data-instance-summary}

<table class="operationdetails" align="left">
	<thead>
		<tr>
			<th>#</th>
			<th>Step</th>
			<th>Request</th>
			<th>Response</th>
    </tr>
	</thead>
	<tbody>
    <tr>
      <td>[1](#create-data-instance-details-preconditions)</td>
      <td>Preconditions:
        * Discover Shape Tree(s) for Target Container (<code>tc</code>)
      </td>
      <td colspan="2">See [Discovery](#discover)</td>
    </tr>
    <tr>
			<td>[2](#create-data-instance-details-parent-validation)</td>
			<td>Validate against parent container</td>
			<td colspan="2">See [Validate Proposed Resource](#validate-proposed-resource)</td>
		</tr>
    <tr>
			<td>[3](#create-data-instance-details-create-resource)</td>
			<td>Create Proposed Resource</td>
			<td></td>
      <td></td>
		</tr>
    <tr>
			<td>[4](#create-data-instance-details-initialize-statics)</td>
			<td>Initialize Static Content</td>
			<td colspan="2">See [Initialize Static Content](#initialize-statics)</td>
		</tr>
    <tr>
			<td>[5](#create-data-instance-details-callhook-indexshapetreedatainstance)</td>
			<td>Call Ecosystem Hook - Index Shape Tree Data Instance</td>
			<td colspan="2">See [Index Shape Tree Data Instance](#ecosystem-indexshapetreedatainstance)</td>
		</tr>
	</tbody>
</table>

See [below](#create-data-instance-details) for more details. <!-- This line isn't especially useful, but bikeshed messes up the links in the above table without some content below it -->

### Operation Details ### {#create-data-instance-details}

#### Preconditions #### {#create-data-instance-details-preconditions}
1. Ensure the [=Parent Container=] (<code>pc</code>) exists.  If not, return a 404 status code.
1. [Discover](#discover) any planted shape tree IRIs managing <code>pc</code>.
	1. Let <code>parentst</code> be the collection of dereferenced shape tree IRIs discovered for <code>pc</code>

#### Validate against parent container #### {#create-data-instance-details-parent-validation}
1. Determine if the [=Parent Container=] (<code>pc</code>) is a [=Managed Container=] by evaluating if <code>parentst</code> is not empty
2. If <code>pc</code> is a [=Managed Container=] call the [validate proposed resource](#validate-proposed-resource) algorithm with parameters:

  <table class="algorithmparams">
    <thead>
      <tr>
        <td><b>Parameter</b></td>
        <td><b>Value</b></td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>uri</code></td>
        <td><code>pc</code></td>
      </tr>
      <tr>
        <td><code>rn</code></td>
        <td>
          If <code>req</code> is a POST then <code>slug</code><br/>
          If <code>req</code> is a PUT then <code>name</code>
        </td>
      </tr>
      <tr>
        <td><code>sth</code></td>
        <td><code>linktst</code></td>
      </tr>
      <tr>
        <td><code>rt</code></td>
        <td>Container</td>
      </tr>
  </table>

#### Create Resource #### {#create-data-instance-details-create-resource}
1. If client-side implementation - Pass through <code>req</code> to server resulting in a POST or PUT (if client-side implementation)
1. If server-side implementation - Apply requested change

Issue: Do not like how this step is laid out.  Want to discuss feedback.

#### Initialize Static Content #### {#create-data-instance-details-initialize-statics}
1. Iterate any tree:contains IRIs within <code>mcst</code>, letting <code>csti</code> be the current IRI in context
1. Let <code>cstist</code> be the shape tree resulting in dereferencing IRI <code>csti</code>
1. If <code>cstist</code> has a rdfs:label value, call algoritm [Initialize Statics](#initialize-statics) with parameters:
    * Let <code>label</code> be the value of rdfs:label for <code>cstist</code>

    <table class="algorithmparams">
      <thead>
        <tr>
          <td><b>Parameter</b></td>
          <td><b>Value</b></td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>pc</code></td>
          <td><code>tc</code></td>
        <tr>
          <td><code>sst</code></td>
          <td><code>cstist</code></td>
        </tr>
        <tr>
          <td><code>rst</code></td>
          <td><code>cst</code></td>
        </tr>
        <tr>
          <td><code>rc</code></td>
          <td><code>tc</code></td>
        </tr>
        <tr>
          <td><code>d</code></td>
          <td><code>d</code></td>
        </tr>
    </table>

#### Call Ecosystem Hook - Index Shape Tree Data Instance #### {#create-data-instance-details-callhook-indexshapetreedatainstance}
1. Call the provided [=ecosystem=]'s [Index Shape Tree Data Instance operation](#ecosystem-indexshapetreedatainstance) with parameters:

  <table class="algorithmparams">
    <thead>
      <tr>
        <td><b>Parameter</b></td>
        <td><b>Value</b></td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>parentContainer</code></td>
        <td><code>pc</code></td>
      </tr>
      <tr>
        <td><code>shapeTree</code></td>
        <td><code>mcst</code></td>
      </tr>
      <tr>
        <td><code>shapeTreeInstance</code></td>
        <td><code>
          If <code>req</code> is a POST then Location header of resource creation<br/>
          If <code>req</code> is a PUT then URI of PUT request
        </code></td>
      </tr>
  </table>

## Delete Data Instance ## {#delete-data-instance}

Note: A Delete Data Instance operation can be performed by either a client or server side agent.

The delete data instance operation is the act of deleting an instance of a shape tree within a managed container.

### Inputs ### {#delete-data-instance-inputs}
* Let <code>req</code> be a DELETE HTTP request with the following characteristics:
	* Let <code>linkst</code> be an optional Link header with the relation of "http://shapetrees.org/#ShapeTree"

### Outputs ### {#delete-data-instance-outputs}
* Standard HTTP response

### Key Terms for Deleting Data Instances ### {#delete-data-instance-terms}
* Let <code>pc</code> be the [=Parent Container=] of the resource being deleted

### Operation Summary ### {#delete-data-instance-summary}

<table class="operationdetails" align="left">
	<thead>
		<tr>
			<th>#</th>
			<th>Step</th>
			<th>Request</th>
			<th>Response</th>
    </tr>
	</thead>
	<tbody>
    <tr>
			<td>[1](#delete-data-instance-details-delete-resource)</td>
			<td>Delete Resource Resource</td>
			<td></td>
      <td></td>
		</tr>
    <tr>
			<td>[2](#delete-data-instance-details-callhook-unindexshapetreedatainstance)</td>
			<td>Call Ecosystem Hook - Unindex Shape Tree Data Instance</td>
			<td colspan="2">See [Unindex Shape Tree Data Instance](#ecosystem-unindexshapetreedatainstance)</td>
		</tr>
	</tbody>
</table>

See [below](#delete-data-instance-details) for more details. <!-- This line isn't especially useful, but bikeshed messes up the links in the above table without some content below it -->

### Operation Details ### {#delete-data-instance-details}

#### Delete Resource #### {#delete-data-instance-details-delete-resource}
1. If client-side implementation - Pass through <code>req</code> to server resulting in a DELETE
1. If server-side implementation - Apply requested change

Issue: Do not like how this step is laid out.  Want to discuss feedback.

#### Call Ecosystem Hook - Unindex Shape Tree Data Instance #### {#delete-data-instance-details-callhook-unindexshapetreedatainstance}
1. Call the provided [=ecosystem=]'s [Unindex Shape Tree Data Instance operation](#ecosystem-unindexshapetreedatainstance) with parameters:

  <table class="algorithmparams">
    <thead>
      <tr>
        <td><b>Parameter</b></td>
        <td><b>Value</b></td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>shapeTree</code></td>
        <td><code>linkst</code></td>
      </tr>
      <tr>
        <td><code>shapeTreeInstance</code></td>
        <td><code>req</code>'s URI</td>
      </tr>
  </table>


Shape Tree Algorithms {#algorithms}
=====================

The below algorithms detail key pieces of logic required for shape tree implementations.

## Validate Proposed Resource Against Parent Container #### {#validate-proposed-resource}

This algorithm is responsible for determining if a proposed resource (which may more specifically be a Container, Resource, or Non-RDF Source) is valid
to be created within a given container.

Note: This algorithm can be performed by either a client or server side agent.

**Inputs**
* Let <code>pc</code> be the URI of [=Managed Container=] that will contain the proposed resource
* Let <code>rn</code> be the resource name of the proposed request:
	* In cases of this algorithm being called as result of a POST, the Slug header value must be provided
	* In cases of this algorithm being called as result of a PUT, the resource name must be provided
* Let <code>sth</code> be the target shape tree hint, from the request's Link header with the relation of "http://shapetrees.org/#TargetShapeTree"
* Let <code>rt</code> be the resource type of proposed resource (Container, Resource, Non-RDF Source)

**Outputs**
* <code>mcst</code>

**Algorithm Details**
1. Determine if the [=Parent Container=] (<code>pc</code>) is a [=Managed Container=] by evaluating if <code>parentst</code> is not empty
2. If <code>pc</code> is a [=Managed Container=], let <code>mcst</code> be the matching contains shape tree which is the result of calling the [matching contained shape tree](#matching-contained-shapetree) algorithm with parameters:

  <table class="algorithmparams">
    <thead>
      <tr>
        <td><b>Parameter</b></td>
        <td><b>Value</b></td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>uri</code></td>
        <td><code>pc</code></td>
      </tr>
      <tr>
        <td><code>rn</code></td>
        <td>
          If <code>req</code> is a POST then <code>slug</code><br/>
          If <code>req</code> is a PUT then <code>name</code>
        </td>
      </tr>
      <tr>
        <td><code>sth</code></td>
        <td><code>linktst</code></td>
      </tr>
      <tr>
        <td><code>rt</code></td>
        <td>Container</td>
      </tr>
  </table>

3. If <code>rt</code> does not match <code>mcst</code>'s tree:expectsType value, return a 422 status code
4. If <code>mcst</code> has a tree:validatedBy value, and the plant operation (<code>req</code>) includes an RDF graph body and ShEx validation is used and a [=Focus Node=] (<code>linkfn</code>) is not present, return a 422 status code
5. Perform a validation of the RDF graph body of <code>req</code> using the <code>mcst</code> tree:validatedBy shape, targeting the graph's <code>linkfn</code>.  If validation fails, return a 422 status code

## Find Matching Contained Shape Tree ## {#matching-contained-shapetree}

This algorithm is responsible for determining which [=shape tree=] within a set of shape trees mentioned in tree:contains is applicable for a given proposed resource.

Issue: This describes a new construct not yet in implementation - should be discussed

Note: This algorithm can be performed by either a client or server side agent.

**Inputs**
* Let <code>uri</code> be the URI of [=Managed Container=] that will contain the proposed resource
* Let <code>rn</code> be the resource name of the proposed request:
	* In cases of this algorithm being called as result of a POST, the Slug header value must be provided
	* In cases of this algorithm being called as result of a PUT, the resource name must be provided
* Let <code>sth</code> be the target shape tree hint, from the request's Link header with the relation of "http://shapetrees.org/#TargetShapeTree"
* Let <code>rt</code> be the resource type of proposed resource (Container, Resource, Non-RDF Source)

**Outputs**
* A single shape tree IRI that should be used for validation

**Algorithm Details**
1. Let <code>mst</code> be the shape trees managing <uri> found by [discovering](#discover) the shape trees
1. Let <code>cst</code> be the shape tree within <code>mst</code> with a tree:contains value(s)
1. Let <code>ccst</code> be the candidate shape trees for matching - populated by each tree:contains of <code>cst</code>
1. If <code>sth</code> is specified
	1. and <code>sth</code> does NOT exist within <code>ccst</code> return a 400 status code
	1. and <code>sth</code> exists within <code>ccst</code> return <code>sth</code>
1. Iterating through <code>ccst</code>, let <code>ccsti</code> be the shape tree currently evaluated
1. If <code>rn</code> matches <code>ccsti</code> tree:matchesUriTemplate using [[RFC6570]] add to potential matches (<code>pm</code>)
1. If <code>pm</code> contains more than 1 matching shape trees, return a status code 400
1. If <code>pm</code> contains exactly 1 matching shape trees, return <code>pm</code>
1. If <code>pm</code> contains 0 matching shape trees:
	1. If <code>ccst</code> does not contain any of tree:AllowAll, tree:AllowResources, tree:AllowContainers, tree:AllowNonRDFSources, return a status code of 422
	1. If tree:AllowNone exists within <code>ccst</code>, return a status code 422
	1. If tree:AllowAll exists within <code>ccst</code>, return null - indicating that while no match was found, <code>pc</code> has been configured to allow resources of any type to be create without matching the shape tree
	1. If tree:AllowResources exists within <code>ccst</code>:
	 	1. And the resource type (<code>rt</code>) is not a Resource, return a status code of 422
		1. And the resource type (<code>rt</code>) is a Resource, return null - indicating that while no match was found, <code>pc</code> has been configured to allow Resources to be create without matching the shape tree
	1. If tree:AllowContainers exists within <code>ccst</code>:
	 	1. And the resource type (<code>rt</code>) is not a Container, return a status code of 422
		1. And the resource type (<code>rt</code>) is a Container, return null - indicating that while no match was found, <code>pc</code> has been configured to allow Containers to be create without matching the shape tree
	1. If tree:AllowNonRDFSources exists within <code>ccst</code>:
	 	1. And the resource type (<code>rt</code>) is not a Non-RDF Source, return a status code of 422
		1. And the resource type (<code>rt</code>) is a Non-RDF Source, return null - indicating that while no match was found, <code>pc</code> has been configured to allow non-RDF Sources to be create without matching the shape tree

## Initialize Static Content ## {#initialize-statics}

This algorithm is responsible for initializing static content that is implied through the creation of its parent.
When called it recursively seeks out resources to be statically created.

Note: This algorithm can be performed by either a client or server side agent.

**Inputs**
* Let <code>pc</code> be the URI of the parent [=container=] any statics would be created within
* Let <code>sst</code> be the static shape tree (having an rdfs:label set) to be initialized
* Let <code>rst</code> be the root shape tree that was planted at the top of this shape tree hierarchy
* Let <code>rc</code> be the root container at the top of this shape tree hierarchy
* Let <code>d</code> be the depth relative between <code>rc</code> and <code>pc</code>

**Outputs**
* Nothing

**Algorithm Details**

1. Let <code>label</code> be the rdfs:label value of the provided 'static' shape tree (<code>sst</code>)
2. Create the expected resource using a PUT in order to have control of resource naming, letting <code>cr</code> be the resulting resource that was create
    1. Set the appropriate Link header with "type" relation based on the tree:expectsType value of <code>sst</code>
3. If the tree:expectsType value of <code>sst</code> is tree:ShapeTreeContainer:
    1. Call algorithm [Update Container Metadata](#update-container-metadata) with parameters:

    	<table class="algorithmparams">
    		<thead>
    			<tr>
    				<td><b>Parameter</b></td>
    				<td><b>Value</b></td>
    			</tr>
    		</thead>
    		<tbody>
          <tr>
            <td><code>tc</code></td>
            <td><code>cr</code></td>
    			<tr>
    				<td><code>rootst</code></td>
    				<td><code>rst</code></td>
    			</tr>
    			<tr>
    				<td><code>st</code></td>
    				<td><code>sst</code></td>
    			</tr>
    			<tr>
    				<td><code>ip</code></td>
    				<td>The calculated relative path between <code>rc</code> and <code>cr</code></td>
    			</tr>
    			<tr>
    				<td><code>rootpath</code></td>
    				<td><code>rc</code></td>
    			</tr>
    	</table>

    1. If <code>sst</code> has any values for tree:contains:
        1. Iterate any tree:contains IRIs within <code>sst</code>, letting <code>cssti</code> be the current IRI in context
        1. Let <code>csstit</code> be the shape tree resulting in dereferencing IRI <code>cssti</code>
        1. If <code>csstit</code> has a rdfs:label value:
            1. Increment <code>d</code>
            1. Recursively call algorithm [Initialize Statics](#initialize-statics) with parameters:

              <table class="algorithmparams">
                <thead>
                  <tr>
                    <td><b>Parameter</b></td>
                    <td><b>Value</b></td>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>pc</code></td>
                    <td><code>cr</code></td>
                  <tr>
                    <td><code>sst</code></td>
                    <td><code>csstit</code></td>
                  </tr>
                  <tr>
                    <td><code>rst</code></td>
                    <td><code>rst</code></td>
                  </tr>
                  <tr>
                    <td><code>rc</code></td>
                    <td><code>rc</code></td>
                  </tr>
                  <tr>
                    <td><code>d</code></td>
                    <td><code>d</code></td>
                  </tr>
              </table>

## Update Container Metadata ## {#update-container-metadata}

This algorithm is responsible for updating the shape tree metadata for a container to reflect what shapetree(s) manage that container
and the container's location relative to the broader hierarchy of shape trees.

Note: This algorithm can be performed by either a client or server side agent.

**Inputs**:
* Let <code>tc</code> be the URI of [=Container=] to update metadata for
* Let <code>rootst</code> be the root [=shape tree=] within a hierarchy of shape tree containers
* Let <code>st</code> be a [=shape tree=] that will manage <code>tc</code>
* Let <code>rootpath</code> be the URI of the root of this shape tree hierarchy, where <code>rootst</code> is planted
* Let <code>ip</code> be the relative path between the <code>rootpath</code> and the URI of <code>tc</code>

**Outputs**:
* Nothing

**Algorithm Details**
1. Perform a HEAD on Target Container <code>tc</code>
	<figure id="fig-container-head-request">
		<figcaption>Discover Target Container Shape Tree Metadata URI - Request</figcaption>
		<pre highlight="http">
		HEAD /data/CommonNotes/
		</pre>
	</figure>

	<figure id="fig-container-head-response">
		<figcaption>Discover Target Container Shape Tree Metadata URI - Response</figcaption>
		<pre highlight="http">
		HTTP/1.1 200 OK
		Link: &lt;/data/CommonNotes/.shapetree&gt;; rel="http://shapetrees.org/#ShapeTree"
		...other headers omitted...
		</pre>
	</figure>

	Let <code>metauri</code> be the URI of the shape tree metadata resource pertaining to <code>uri</code>.

1. Perform a GET on the Target Container's Shape Tree metadata (<code>metauri</code>)
	<figure id="fig-container-get-metadata">
		<figcaption>Dereference Target Container Shape Tree Metadata URI - Request</figcaption>
		<pre highlight="http">
		GET /data/CommonNotes/.shapetree
		</pre>
	</figure>

	<figure id="fig-container-get-response-managed">
		<figcaption>Dereference Target Container Shape Tree Metadata URI - Managed Response</figcaption>
		<pre highlight="turtle">
		@prefix tree: &lt;http://www.w3.org/ns/shapetree#&gt;.

		&lt;#shapetree&gt;
	  	tree:hasShapeTreeLocator &lt;#bc1b490a-537d-4749-b778-cd7d6da3ac56&gt; .

		&lt;#bc1b490a-537d-4749-b778-cd7d6da3ac56&gt;
			a tree:ShapeTreeLocator ;
	  	tree:hasRootShapeTree &lt;http://commonnote.example/CommonNoteShapeTree#container&gt; ;
	  	tree:hasShapeTree &lt;http://commonnote.example/CommonNoteShapeTree#container&gt; ;
	  	tree:hasShapeTreeInstancePath "." ;
	  	tree:hasShapeTreeInstanceRoot &lt;/data/CommonNotes/&gt; .
		</pre>
	</figure>

	<figure id="fig-container-get-response-unmanaged">
		<figcaption>Dereference Target Container Shape Tree Metadata URI - Unmanaged Response</figcaption>
		<pre highlight="http">
		HTTP/1.1 404 NOT FOUND
		</pre>
	</figure>

  If a 404 is returned that indicates that no shape trees manage this container.
  Let <code>eg</code> be the existing metadata graph resulting from dereferencing and parsing <code>metauri</code>.

3. Populate the metadata graph with triples

Using <code>eg</code>, if it exists, otherwise a new graph, the following triples should be added:

  <table class="operationdetails" align="left">
  	<thead>
  		<tr>
  			<th>Subject</th>
  			<th>Predicate</th>
  			<th>Object</th>
  			<th>Description</th>
      </tr>
  	</thead>
  	<tbody>
  		<tr>
  			<td nowrap>&lt;#<b><i>generated UUID</i></b>&gt;</td>
  			<td>rdf:type</td>
  			<td>tree:ShapeTreeLocator</td>
  			<td>Indicates the RDF class of the subject</td>
  		</tr>
  		<tr>
  			<td>&lt;#<b><i>generated UUID</i></b>&gt;</td>
  			<td>tree:hasRootShapeTree</td>
  			<td><b><i>rootst</i></b></td>
  			<td>Describes the shape tree planted at the root of this shape tree hierarchy</td>
  		</tr>
  		<tr>
  			<td>&lt;#<b><i>generated UUID</i></b>&gt;</td>
  			<td>tree:hasShapeTree</td>
  			<td><b><i>st</i></b></td>
  			<td>Describes the shape tree planted at this container</td>
  		</tr>
  		<tr>
  			<td>&lt;#<b><i>generated UUID</i></b>&gt;</td>
  			<td>tree:ShapeTreeInstancePath</td>
  			<td><b><i>ip</i></b></td>
  			<td>Describes a relative path from the current container to the root container of this shape tree hierarchy</td>
  		</tr>
  		<tr>
  			<td>&lt;#<b><i>generated UUID</i></b>&gt;</td>
  			<td>tree:hasShapeTreeInstanceRoot</td>
  			<td><b><i>rootpath</i></b></td>
  			<td>Describes the URI to the root container of this shape tree hierarchy</td>
  		</tr>
  		<tr>
  			<td>&lt;#shapetree&gt;</td>
  			<td>tree:hasShapeTreeLocator</td>
  			<td>&lt;#<b><i>generated UUID</i></b>&gt;</td>
  			<td>Describes a navigable relationship to a given tree:ShapeTreeLocator</td>
  		</tr>
  	</tbody>
  </table>

4. Persist the above triples to <code>metauri</code>.

Navigating Planted Shape Trees {#navigating}
=====================

Issue: Is this still needed?  It explains ShapeTreeLocator, but what do you do with this information?

The shape tree describes data instances which are resource hierarchies in an LDP Container hierarchy.
Every Managed Container has metadata that expresses "where" that managed container is located in reference to the Instance Root of the planted shape tree:

* <b>Shape tree Instantiation Root</b> &mdash; the IRI of the container that represents the planted shape tree.
* <b>Shape tree Instantiation Path</b> &mdash; a relative IRI identifying a location within a shape tree instance. This is represented in RDF as a string literal.
* <b>Root shape tree</b> &mdash; the IRI of the planted shape tree's subject.
* <b>Current shape tree</b> &mdash; a location within a shape tree identified by the IRI of the subject node of that shape tree in the shape tree hierarchy.

<dfn>instantiate static</dfn> (<code>shapeTreeInstantiationShapeTree</code>, <code>shapeTreeS</code>) instantiates the Static Containers implied by shapeTreeInstantiationShapeTree <a class="excode" href="https://github.com/shapetrees/specification/blob/master/util/shapetree.js#L309-L331"></a>

1. instantiate a <b>shape tree instance</b> &mdash; an LDP Container with a Resource Graph conformant to <span class="hljs-name">&lt;#ShapeTreeInstanceStep&gt;</span> below:

<figure>
	<pre highlight="shexc">
	&lt;#ShapeTreeInstance&gt; {
	  a [tree:ShapeTreeLocator] ;
	  tree:shapeTreeRoot IRI;
	  tree:shapeTreeInstancePath xsd:string;
	  tree:shapeTreeInstanceRoot IRI;
	  tree:hasShapeTree IRI;
	}
	</pre>
</figure>

1. for each <code>child shape tree</code> in { <code>shapeTreeInstantiationShapeTree</code>, tree:contains, * }
	* if <code>child shape tree</code> has an rdfs:label <code>container label</code>
		* apply <a>instantiate static</a>(<code>child shape tree</code>, path.join(<code>shapeTree</code>, <code>container label</code>))


Describing Shape Trees {#describing}
=====================
External graphs adhering to the SKOS data model can be optionally used to describe the shape tree in human-readable terms.

Specifying a <code>tree:hasShapeTreeDecoratorIndex</code> predicate within shape tree definition enables clients to discover available human-readable definitions of that shape tree.


Definitions {#definitions}
=====================
The following terms are used throughout this specification:
	* <dfn>Container</dfn> -- Tte generalized notion of a collection of resources; implementations of shape trees may use a container implementation such as [[LDP]]
	* <dfn>Managed Container</dfn> -- any [=Container=] that has a [=shape tree=] planted in it. A [=Managed Container=] may be an [=Instance Root=] or hierarchically nested within the resource hierarchy.
	* <dfn>Unmanaged Container</dfn> -- any [=Container=] which is not described by a shape tree
	* <dfn>Supported RDF Format</dfn> -- a textual representation of an RDF graph in a format that can be accurately and losslessly parsed to that RDF graph.
	* <dfn>Body Graph</dfn> -- the RDF graph derived from parsing the body of an HTTP request with a parser determined by the Content-type: header of that HTTP request.
	* <dfn>Static Container</dfn> -- any [=Container=] which is implied by the existence of the parent resource, denoted by a rdfs:label predicate within a [=shape tree=].
	* <dfn>Resource Graph</dfn> -- an RDF graph obtained by parsing the body of a GET on a resource.
	* <dfn>SKOS Graph</dfn> -- an RDF graph conforming to [[[skos-reference]]] [[skos-reference]] data model.  For purposes of [=shape trees=] a [=SKOS Graph=] is used to describe a [=shape tree=] in human-readable terms.
  * <dfn>Ecosystem</dfn> -- a software environment with an understanding of [=shape tree=] concepts, making use of lifecycle hooks call from [=shape tree=] processing
