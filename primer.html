<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
    <title>ShapeTrees Primer</title>
    <script async class="remove" src="//www.w3.org/Tools/respec/respec-w3c-common">
    </script>
    <script class="remove">
      var respecConfig = {
        shortName:      "shapetrees-spec",
        specStatus:     "ED",
        // specStatus:     "WG-NOTE",
        noRecTrack: true,
        edDraftURI:  "https://shapetrees.github.io/specification/primer",
        editors:  [
          { name: "Eric Prud'hommeaux" , w3cid: "2112" },
          { name: "Justin Bingham" },
          { name: "Josh Collins" }
        ],
        cg: "Solid",
        wgURI: "https://www.w3.org/community/solid/",
        // wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/53154/status",
        github: {
          repoURL: "https://github.com/shapetrees/specification/",
          branch: "master"
        },
      };
    </script>
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css"/>
    <link rel="stylesheet" href="local.css"/>
    <style>
.cross::before { content: "(see spec)"; font-size: small; vertical-align: top; background-color: buttonface; }

/* draw tree per https://two-wrongs.com/draw-a-tree-structure-with-only-css */
.clt, .clt ul, .clt li {
     position: relative;
}

.clt ul {
    list-style: none;
    padding-left: 32px;
}
.clt li::before, .clt li::after {
    content: "";
    position: absolute;
    left: -12px;
}
.clt li::before {
    border-top: 1px solid #000;
    top: 9px;
    width: 8px;
    height: 0;
}
.clt li::after {
    border-left: 1px solid #000;
    height: 100%;
    width: 0px;
    top: 2px;
}
.clt ul > li:last-child::after {
    height: 8px;
}
li.choice {
    list-style999: none;
    margin-left999: -2.5em;
    padding-left: .2em;
    border-left: .5em solid #a7a;
}
li.choice > ul > li {
}
.choice .either {
    font-weight: bold;
    color: #747;
}
    </style>
  </head>
  <body>

    <section id="abstract">
      <p>
        Semantic Web Applications interoperate by sharing semantics of terms and constellations of data structures.
        This primer introduces ShapeTrees and describes how Semantic Web Applications use them to consistently interoperate over constellations of data structures organized in resource hierarchies used by protocols such as <a href="https://www.w3.org/TR/ldp/">LDP</a> and <a href="https://www.solidproject.org">Solid</a>.
      </p>
    </section>

    <section id="sotd">
      <p>
        This is a proposal for the structure and use of ShapeTrees in Solid.
        It is possible that this or a derivative document will become a Solid specification.
      </p>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        Realizing the value proposition of the Semantic Web lies in building useful and robust applications that can interoperate over linked data.
        Protocols such as <a href="https://www.w3.org/TR/ldp/">LDP</a> and <a href="https://www.solidproject.org">Solid</a> organize linked data graphs into resource hierarchies, providing a foundation upon which these robust and interoperable applications can be created.
      </p>
      <p>
        Application interoperability depends on applications sharing semantics for relationships and data structures.
        RDF&apos;s foundation in unambiguous identifiers provides an infrastructure that allows for interoperability without specifically encouraging it.
        Within a single resource, shapes languages (e.g. ShEx and SHACL) provide machine-readable, enforceable data structure definitions.
        For applications that operate on constellations of resources, ShapeTrees express the layout of those resources and associate them with their respective shapes.
      </p>
      <p>
        ShapeTrees marry RDF vocabularies, shapes, and resources into "little trees" that
        provide detailed ShapeTrees for machine to machine interoperability,
        while at the same time creating models and representions that humans can
        easily comprehend, such as medical records, notes, notebooks,
        calendars, and financial records. Consequently, we can use ShapeTrees to provide
        data boundaries that machines can interoperate with and humans can understand.
      </p>
      <p>
        A ShapeTree defines a prospective tree of related resources which can be read and written by applications.
        The ShapeTree associates each of these resources with a shape.
        This allows one to treat a set of related resources as a single grouping, and apply that to a range of operations including access control, data organization, data validation, and data migration.
        Since the ShapeTree boundaries that establish these groupings are easily understood by humans, it allows them to perform these operations intuitively.
      </p>
      <p>
        ShapeTrees are defined as an RDF graph structure and a set of expected behaviors of agents respecting that graph structure.
        These semantics can be implemented by a server, a client-side library, or a privilenged third-party helper application.
        Communication, including error reporting, is defined in terms of HTTP; allowing a single definition to define the behaviors for servers, clients and third-party applications.
      </p>
    </section>

    <section id="structure">
      <h2>ShapeTree Structure <a class="cross" href="spec#structure"></a></h2>
      <p>
        The following image introduces ShapeTrees by way of an example ShapeTree for interoperable notes called "CommonNote".
        It captures notes, any images included therein, as well as the note&apos;s citations.
      </p>
      <p>
        The example image includes three columns:
      </p>
      <ol>
        <li>Shape definitions (expressed in ShEx) for the resources described by the CommonNote ShapeTree</li>
        <li>A ShapeTree (expressed in Turtle) for CommonNote</li>
        <li>Example instances of the CommonNote ShapeTree (a "resource hierarchy")</li>
      </ol>
        <style>
#img1 > img {
    width: 90%;
    height: auto;
    padding-left: 5%;
    align-self: self-start;
    /* object-fit: cover; */
}
#img1 > span {
    text-decoration: underline;
    padding: 0 9ex;
}
        </style>
      <div id="img1">
<span>Shapes (ShEx)</span>
<span>ShapeTree (Turtle)</span>
<span>Resources</span>
        <img src="shape-tree.svg" alt="colored example of ShEx schema, ShapeTree, and resource hierarchy"/>
      </div>
      <p>
        Here, <code style="color: #005555;">/data/medicalNotes</code> and <code style="color: #005555;">/data/astronomy/notes</code> are both plants of the <code style="color: #005555;">&lt;#container&gt;</code> ShapeTree step.
        They are both LDP Containers per <code style="color: #005555;">&lt;#container&gt; tree:expectsType tree:ShapeTreeContainer</code> and could contain any number of note data instance per <code style="color: #005555;">tree:contains &lt;#note&gt;</code>.
        In this example, <code style="color: #770033;">xrays-2019-08</code>, <code style="color: #770033;">GP-2020-04-18</code> and <code style="color: #770033;">blue-shift</code> respectively are data instances of the <code style="color: #770033;">&lt;#note&gt;</code> ShapeTree.
        Each contains a binary <code style="color: #337700;">image</code> and blue-shift has a <code style="color: #330077;">citation</code>.
      </p>
      <p>
        A ShapeTree document can contain multiple ShapeTree subjects. A given subject in a ShapeTree resource can be referenced and used on its own as a standalone ShapeTree, or as part of a more connected tree of ShapeTrees.
        The ShapeTree describing the <code style="color: #330077;">citation</code> has the subject node <code style="color: #330077;">&lt;#citation&gt;</code>.
        This ShapeTree asserts that associated resources (e.g. <code style="color: #330077;">cit-M33.ttl</code>) must be LDP Resources per <code style="color: #330077;">&lt;#citation&gt; tree:expectsType tree:ShapeTreeResource</code>, must have a name matching a URI template (i.e. must start with "cit-") per <code style="color: #330077;">&lt;#citation&gt; tree:matchesUriTemplate "cit-{name}"</code>, and must conform to the shape <code style="color: #330077;">&lt;CommonNote#Citation&gt;</code> per <code style="color: #330077;">&lt;#citation&gt; tree:validatedBy &lt;CommonNote#Citation&gt;</code>.
      </p>
        <style>
#img2 > img {
    float:left;
    width: 30%;
    height: auto;
    padding-left: 5%;
    align-self: self-start;
    /* object-fit: cover; */
}
#img2 > div {
    float:left;
    width:65%;
}
.proscons > div {
    float:left; width: 49%
}
.proscons > div:nth-child(1) {
    border-right: medium solid black;
}
.proscons > div > p {
    font-weight: bold;
    text-align: center;
    margin: 0;
    border-bottom: medium solid black;
}
        </style>
        <div id="img2">
          <div>
            <p>
              The above resource hierarchy includes multiple locations where data instances of the ShapeTree CommonNote 
              <code style="color: #770033;">&lt;#note&gt;</code>
              can be stored (medicalNotes and astronomy/notes).
              Many systems make life simpler for users by providing dedicated places to store specific types of data structures.
              This provides applications with the ability to store data without prompting the user for a storage target.
            </p>
            <p>
              The example on the right implies a single location to store all CommonNote <code style="color: #770033;">&lt;#note&gt;</code> instances.
              The resource name for these individual <code style="color: #770033;">&lt;#note&gt;</code> instances could come from the ShapeTree name, a randomly generated sequence like a uuid, or some other opaque identifier invented by the system.
              Validation by the <code style="color: #005555;">&lt;#container&gt;</code> ShapeTree step ensures that only <code style="color: #770033;">&lt;#note&gt;</code> instances can be stored.
              Instances of <code style="color: #770033;">&lt;#note&gt;</code> ShapeTrees can be discovered easily in this scheme, and the layout is conducive to tag-based organization and access control.
            </p>
          </div>
        <img src="mono-shape-tree.svg" alt="colored example of single-instance resource hierarchy"/>
      </div>
      <div style="clear:both"></div>
      <div class="issue">
        <p>
          Should ShapeTree resources include a ShapeTree for their managed container?
          In the above ShapeTree, the triples:
        </p>
        <pre style="color: #005555;" class="plaintext">
&lt;#container&gt; tree:expectsType tree:ShapeTreeContainer ;
  tree:contains &lt;#note&gt; .
        </pre>
        <p>
          describe not an instance of a note but a container of such instances.
          Without these triples, the outer-most step (the one that is not the object of any <code>tree:contains</code> arcs) is <code>&lt;#note&gt;</code>.
          This makes it easier to, at a high-level, assert that the ShapeTree is about Notes rather than containers of notes.
        </p>
        <div class="proscons">
          <div>
            <p>Reasons not to include</p>
            <ol>
              <li>Simplifies message.</li>
              <li>Aligns with traditional patterns for data modeling and separation of concern</li>
              <li>Could either:
              <ul>
                <li>Describe outer container with a second ShapeTree,</li>
                <li>Leave content model of outer container implicit in the existance of any ShapeTree doc (i.e. system automatically creates a container for it).</li>
              </ul>
            </li>
            </ol>
          </div>
          <div>
            <p>Reasons to include</p>
            <ol>
              <li>Re-uses existing mechanism (<code>tree:contains</code>) for declaring a container content model.<br/>
              This works for homogeneous and heterogeneous (those with multiple types of members)</li>
              <li>avoids either:<ul>
              <li>Second ShapeTree,</li>
              <li>Implicit containership semantics.</li>
            </ul></li>
            </ol>
          </div>
          <div style="clear:both;"></div>
        </div>
      </div>
      <p>
        A ShapeTree is a tree structure of one or more ShapeTree subjects which in turn describes a tree structure of Resources (effectively a hierarchy of containers and resources).
        Each ShapeTree can be referenced and used on its own as a standalone ShapeTree. Each container or resource is described by <dfn>ShapeTree</dfn>.
      </p>
      <p>
        A ShapeTree consists of:
      </p>
      <ul>
        <li>an <dfn>id</dfn>: an addressable label for this ShapeTree.<br/>
        As with all RDF structures, providing an id makes is possible to address this entity from outside the document.</li>
        <li>an <dfn>expectsType</dfn>: type of the associated resource: <code>tree:ShapeTreeContainer</code>, <code>tree:ShapeTreeResource</code> OR <code>tree:ShapeTreeNonRDFResource</code>.<br/>
        The expectsType specifies whether the associated resources should be a container, a normal resource, or an non-RDF source.  ShapeTree implementations
        will map these resource types to the appropriate constructs for the intended platform (i.e. in an LDP environment tree:ShapeTreeResource would map to ldp:Resource).
        </li>
        <li class="choice"><span class="either">either of:</span>
        <ul>
          <li>a <dfn>label</dfn>: label for a resource which will always be created;<br/>
          This is used when resources with specific names will appear in the resource hierarchy.</li>
          <li>a <dfn>matchesUriTemplate</dfn>: pattern for a resource to be matched against a POSTed Slug: header or a resource name in a PUT/PATCH.<br/>
          This is used to constrain resource creation based resource name patterns.</li>
        </ul>
        </li>
        <li>a <dfn>validatedBy</dfn>: The RDF graph structure of any POSTed or PUT resource must conform to this shape;<br/>
          This allows ShapeTrees to ensure that the data in the resource hierarchy conforms to the expected schemas.</li>
        </li>
        <li>an optional <dfn>supports</dfn>: an IRI to another ShapeTree.<br/>
        This captures a relationship where a ShapeTree is dependent on another for purposes of ancillary tasks like indexing.  It is expected to describe resources which extend or another ShapeTree.
        </li>
        <li>an optional <dfn>contains</dfn>: a list of nested ShapeTrees.<br/>
        This captures the containership of a conforming resource hierarchy.  In addition to containing other ShapeTrees, this list may include
        <code>tree:AllowNone</code>, <code>tree:AllowAll</code>, <code>tree:AllowContainers</code>, <code>tree:AllowResources</code>, <code>tree:AllowNonRDFSources</code> which described the intended behavior when a resource is created that does not adhere to any matching matchesUriTemplate predicates.
      </li>
        <li>an optional <dfn>references</dfn>: a list of referenced ShapeTrees.<br/>
        These provide advice that the data in resources described by this ShapeTree references another ShapeTree.  This enables connectivity of ShapeTrees
        without requiring direct nesting/containment of those relationships.
        </li>
      </ul>
      <p>Annotating all ShapeTrees within a given resource is an optional <dfn>hasShapeTreeDecoratorIndex</dfn>: An IRI containing an index of SKOS graphs.<br/>

         As detailed in <a href="#describing">Describing Shape Trees</a> below, SKOS provides an extensible means to describe a shape tree in human-readable terms.  The <code>tree:hasShapeTreeDecoratorIndex</code> allows shape tree maintainers to provide a reference to SKOS graphs that accurately and reliably describe the shape tree as intended, which is important for authorization use cases.  
       </li>
    </section>

    <section id="creating">
      <h2>Planting a ShapeTree</h2>
      <p>
        The above example describes an instance at <code style="color: #005555;">/data/CommonNotes</code>.
        This is an LDP Container which is constrained to contain only instances of <code>&lt;CommonNoteShapeTree#note&gt;</code>.
        This container is described by the ShapeTree <code>&lt;CommonNoteShapeTree#container&gt;</code>:
      </p>
      <pre><code class="nohighlight" style="color: #005555;">
&lt;#container&gt; tree:expectsType tree:ShapeTreeContainer ;
  tree:contains &lt;#note&gt; .
      </code></pre>
      <p>
        In order to create this, an application like NeverNote would use a <b>plant</b> operation to create an instance of the <code style="color: #005555;">&lt;#container&gt;</code> ShapeTree.
        This plant operation is a POST to the parent Container with one or more <code>rel="ShapeTree"</code> Link header <a class="excode" href="https://github.com/shapetrees/specification/blob/master/test/test-harness.js#L63-L69"></a>.
        The resulting LDP Container for CommonNotes is expected to be shared with other applications.
        Below, we use the name "OtherNote" as an example of another application which can consume and process data conforming to the shapes referenced by the CommonNote ShapeTree.
      </p>
      <div class="example">
        <p><a href="https://github.com/shapetrees/specification/blob/master/test/cal.test.js#L47-L48">associated test</a></p>
        <pre class="http nohighlight"><code>
POST /data/
Slug: CommonNotes
Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel="type"
Link: &lt;<a href="https://github.com/shapetrees/specification/blob/master/solidApps/staticRoot/nevernote/NeverNoteShapeTree.jsonld">http://commonnote.example/CommonNoteShapeTree#container</a>&gt;; rel="ShapeTree"
        </code></pre>
      </div>
      <p>
        The response identifies a LDP Container for CommonNotes notes:
      </p>
      <style>
        .caption { margin-bottom: -4ex; font-weight: bold; }
      </style>
      <div>
        <p class="caption">HTTP Response</p>
        <pre><code class="example shapetree turtle">
HTTP 201 CREATED
Location: http://pod.example/data/CommonNotes/
Content-type: text/turtle; charset=utf-8
Content-length: 396
        </code></pre>
      </div>

      <!-- <section id="[planted-image"> -->
      <!--   <h3>Resulting ShapeTree Instance on a Pod</h3> -->
        <p>
          Planting a ShapeTree results in a new LDP Container in the resource hierarchy.
          Metadata associated with this container describes the planted ShapeTree that manages the contents of the container.
        </p>
        <p class="caption">Contents of http://pod.example/data/CommonNotes/ related metadata</p>
        <pre><code class="example shapetree turtle">
@prefix ldp: &lt;http://www.w3.org/ns/ldp#&gt;.
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
@prefix tree: &lt;http://www.w3.org/ns/shapetree#&gt;.
@prefix dc: &lt;http://purl.org/dc/terms/&gt;.
@prefix dcterms: &lt;http://purl.org/dc/terms/&gt;.

&lt;&gt; 
  tree:hasShapeTreeLocator &lt;#bc1b490a-537d-4749-b778-cd7d6da3ac56&gt; .

&lt;#bc1b490a-537d-4749-b778-cd7d6da3ac56&gt;
  tree:hasRootShapeTree &lt;http://commonnote.example/CommonNoteShapeTree#container&gt; ;
  tree:hasShapeTree &lt;http://commonnote.example/CommonNoteShapeTree#container&gt; ;
  tree:hasShapeTreeInstancePath "." ;
  tree:hasShapeTreeInstanceRoot &lt;/data/CommonNotes/&gt; .
        </code></pre>
      <!-- </section> -->
    </section>

    <section id="updating">
      <h2>Creating Data Instances <a class="cross" href="spec#post-managed"></a></h2>
      <p>
        Despite NeverNote having planted the LDP Container <code>/data/CommonNotes</code>, it could be another application, OtherNote, which first creates data there.
      </p>
      <p>
        When POSTing to any managed Container, there will be a corresponding step in the ShapeTree.
        If the step includes a shape, the POST must include a Link: rel="focusNode" header to identify the node in the POSTed data that should conform to that shape.
      </p>
          <pre><code class="example shapetree turtle">
POST /data/CommonNotes/
Link: &lt;#note1&gt;; rel="focusNode"

PREFIX : &lt;http://nevernote.example/ns#&gt;
PREFIX ldp: &lt;http://www.w3.org/ns/ldp#&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
PREFIX geo: &lt;http://www.opengis.net/ont/geosparql#&gt;

&lt;#note1&gt;
  :title "Note1" ;
  :content "Don't believe the hype!" ;
  :updated "2020-01-01T12:34:00Z"^^xsd:dateTime ;
  :tagNames ("tag1" "tag2") .
          </code></pre>
      <p>
        When an application POSTs to a Managed Container, the ShapeTree-aware agent handling the POST locates the appropriate ShapeTree that is contained,
        via the <code>tree:contains</code> predicate, that matches its URI template.
        <ul>
          <li>If the ShapeTree includes a <code>tree:validatedBy</code> predicate, the POST body is parsed and the focus node is tested for conformance.</li>
          <li>If the posted resource is invalid, it will return with a 422 Unprocessable Entity message.</li>
          <li>If no matching ShapeTree is found, the agent will use any present <code>tree:Allow*</code> IRIs to determine whether to allow the new resource.</li>
          <li>If the posted resource is valid, the typical LDP processing will create an entity whose contents include the POSTed body.</li>
        </ul>
      </p>
    </section>

    <section id="describing">
      <h2>Describing Shape Trees <a class="cross" href="spec#describing-shapetrees"></a></h2>
      <p>
        To aid in the human-readability of Shape Trees, one or more SKOS graphs can be used to provide a textual representation of the structure.
      </p>
      <p>
        Making use of the <code>tree:hasShapeTree</code> predicate, labels can be applied to specific Shape Trees using any language.
        A SKOS index document allows for discovery of multiple definitions of a Shape Tree supporting multiple language preferences and cognitive abilities.
        The convention on how this index of SKOS graphs is structured and used, along with the rules to govern the selection of the appropriate graph for a user is the responsibility of the ecosystem using Shape Trees.
      </p>
      <p>
        A sample SKOS index document, with references to English and Russian representations of the CommonNotes Shape Tree:
      </p>
      <pre><code class="example shapetree turtle">
<#index>
  a tree:ShapeTreeDecoratorIndex ;
  treeIndex:hasSeries <#en>, <#ru> .

<#en> 
  a tree:ShapeTreeDecoratorSeries ;
  tree:hasHierarchy <#en-v1>, <#en-v1.1> .

<#en-v1>
  a tree:ShapeTreeDecoratorHierarchy ;
  xsd:lang "en" ;
  tree:hasVersion "1.0" ;
  tree:hasSkosGraph <https://commonnote.example/CommonNoteGraph-en-v1#root> ;
  tree:hasSHA3256Hash: "92ac6762c129666107299c2386420fdb31b12df7723b3aa0d132485fda864a47" .

<#en-v1.1>
  a tree:ShapeTreeDecoratorHierarchy ;
  xsd:lang "en" ;
  tree:hasVersion "1.1" ;
  tree:hasSkosGraph <https://commonnote.example/CommonNoteGraph-en-v1.1#root> ;
  tree:hasSHA3256Hash: "74a468adf584231d0aa3b3277fd21b13bdf0246832c992701666921c2676ca29" .

<#ru> 
  a tree:ShapeTreeDecoratorSeries ;
  treeIndex:hasHierarchy <#ru-v1> .

<#ru-v1>
  a tree:ShapeTreeDecoratorHierarchy ;
  xsd:lang "ru" ;
  tree:hasVersion "1.0" ;
  tree:hasSkosGraph <https://commonnote.example/CommonNoteGraph-ru-v1#root> ;
  tree:hasSHA3256Hash: "7d8cf659fdbd69618658e043c2c6e8c8e9395f4b652a38c2e5922eb7a51de42c" .
      </code></pre>
      <p>
        A sample SKOS graph <code>(<#en-v1>)</code>, in English, defining the terms in the CommonNotes Shape Tree:
      </p>
      <pre><code class="example shapetree turtle">
@prefix f: &lt;/data/CommonNotesShapeTree#container&gt; .
@prefix tree: &lt;http://www.w3.org/ns/shapetree#&gt; .
@prefix skos: &lt;http://www.w3.org/2004/02/skos/core#&gt; .
@prefix skosxl: &lt;http://www.w3.org/2008/05/skos-xl#&gt; .

<#root> a tree:ShapeTreeLabel ; tree:hasShapeTree f:root ; skosxl:prefLabel [ skosxl:literalForm "Note Container"@en ] ; skos:narrower <#note> .
   <#note> a tree:ShapeTreeLabel ; tree:hasShapeTree f:note ; skosxl:prefLabel [ skosxl:literalForm "Text content of a note"@en ] ; skos:narrower <#citation>, <#image> .
      <#citation> a tree:ShapeTreeLabel ; tree:hasShapeTree f:citation ; skosxl:prefLabel [ skosxl:literalForm "Citation to another document within a note"@en ] .
      <#image> a tree:ShapeTreeLabel ; tree:hasShapeTree f:citation ; skosxl:prefLabel [ skosxl:literalForm "Embedded image or graphic within a note"@en ] .
          </code></pre>

      <p>
        A sample SKOS graph <code>(<#ru-v1>)</code>, in Russian, describing the same CommonNotes Shape Tree:
      </p>
      <pre><code class="example shapetree turtle">
@prefix f: &lt;/data/CommonNotesShapeTree#container&gt; .
@prefix tree: &lt;http://www.w3.org/ns/shapetree#&gt; .
@prefix skos: &lt;http://www.w3.org/2004/02/skos/core#&gt; .
@prefix skosxl: &lt;http://www.w3.org/2008/05/skos-xl#&gt; .

<#root> a tree:ShapeTreeLabel ; tree:hasShapeTree f:root ; skosxl:prefLabel [ skosxl:literalForm "контейнер для заметок"@ru ] ; skos:narrower <#note> .
   <#note> a tree:ShapeTreeLabel ; tree:hasShapeTree f:note ; skosxl:prefLabel [ skosxl:literalForm "текстовое содержание заметки"@ru ] ; skos:narrower <#citation>, <#image> .
      <#citation> a tree:ShapeTreeLabel ; tree:hasShapeTree f:citation ; skosxl:prefLabel [ skosxl:literalForm "Цитирование другого документа в заметке"@ru ] .
      <#image> a tree:ShapeTreeLabel ; tree:hasShapeTree f:citation ; skosxl:prefLabel [ skosxl:literalForm "Встроенное изображение или изображение в заметке"@ru ] .
          </code></pre>

    </section>    

    <script src="http://www.w3.org/2019/Talks/1209-swat4ls-egp/highlight.pack.js"></script>
    <script src="http://www.w3.org/2019/Talks/1209-swat4ls-egp/highlight-shexc.js"></script>
    <!-- <script src="WWW/2019/Talks/1209-swat4ls-egp/highlight-shexc.js"></script> -->
    <script>
      // TODO: add ShEx highlighter to respec
      hljs.registerLanguage('shexc', hljsDefineShExC);
      hljs.registerLanguage('turtle', hljsDefineTExpr);
      (['DOMContentLoaded', 'load']).forEach(e => addEventListener(e, init, false));
      let inited = false;

      function hljsDefineTExpr (highlightjs) { // works pretty well for Turtle.
        const ret = hljsDefineShExC(highlightjs, 'tripleConstraint');
        ret.disableAutodetect = true;
        return ret;
      }

      function init () {
        if (inited) return;
        inited = true;
        ([400, 800, 1600]).forEach(
          tOut => setTimeout(highlightAll, tOut)
        )
      }

      function highlightAll () {
        console.log(new Date())
        try {
          const blocks = document.querySelectorAll('.shexc,.turtle');
          [].forEach.call(blocks, (b) => {
            hljs.highlightBlock(b);
          });
        } catch (e) {}
      }
    </script>
  </body>
</html>
